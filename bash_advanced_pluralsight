#Shell Scripting with Bash
#Reindert-Jan Ekker (Pluralsight)

#A first look at shell scripts
#Hello World 
#Create file hw
echo Hello world
#Not on path bash searhes for executables
#Specify that the executable is in the current directory
./hw
=> permission denied
chmod u+x hw
./hw
#Works!
#To revoke
chmod u-x hw

#A script is nothing more than a text-file containing code
#Usually run by interpreter
#bash interpreter here
#Reads every line in file
#Every line that contains a command is executed
#in order from top-to-bottom (well, not entirely true)

#To make a script executable for EVERYONE on the system, replace 'u' with 'a'
chmod u+x filename
chmod a+x filename		Make it executable for everyone
chmod a-x filename		Remove

#$1 variable holds first argument passed to script
$* variable holds all the arguments passed to a script

#To set path to /bin, use the following
PATH=$PATH:~/bin
#However, and inspection of .profile shows this now unnecessary
#/bin is added to path as long as /home/bin exits!

#See here for a good ref
# http://stackoverflow.com/q/11709374/499167
#Above good on need to EXPORT the PATH varialble

#eg add the folowing to  ~/.profile
PATH=$PATH:/home/me/play
export PATH
#To get to work, execute the following
 . ~/.profile

 #Tip make a folder to keep scripts
 #By convention this is /home/bin
 Start all scripts with shebang or hash-bang
 #! 
 #After these two characters, declare which interpreter should run code
 #Can also use this line to specify options with interpreter

 # Remember! Hash-bang slash-bin slash-bash 

 #Naming Scripts

 #if you give a script a name that is already taken, 
 #such as 'test' or 'if', you can only execute by
 #giving the full path. Avoid
 #To test name validity use type
 type test

 #Variables
 #Variables allow you to termporarily store data in memory
 #and then retrieve that data by name

 greeting="hello"
 echo $greeting

 ab=filname.txt
 vim $ab			a goodie
 rm $ab				removes		
 				!!Use with extreme care
 				file will also be removed

files="myfile1 myfile2"
touch $myfiles			Two commands are created

#bash does not give error if you use undefined variable
#instead it uses the empty string as value

#variable assinment must be a single word.
#soo ..
newgreeting="hello, $USER"
echo $newgreeging
#Do not put spaces around equals sign when doing assignments
#But be careful of this
dangerous="rm myfile.txt"
$dangerous			Removes the file!
echo $dangerous			Will SAFELY tell what is in there

#To get the value for a variable prefix with '$' sign
#and use 'echo' for safety reasons

#Variable names must be letters, numbers and underscores ONLY
#First character should be a letter or an underscore
#Cannot start variable name with a number
#Variable names are case-sensitive
#Use of UPPERCASE variable names is strongly discouraged
#Bash predefined variables are uppercase, and don't want to overright
#Good habit to only use lc names for variables

#Make the note-taking program interactive

#read command will take user input an put it in a variable
read hello

man builtins		#This is an extremely useful command
help			#help is a bash command
help read
-p 			Show a prompt to the user

#Good habit: surround your variables with quotes
#Use "$x" instead of $x
#Among other things, prevents surprises when data contains spaces
#Use double quotes, as this does not escape the dollar sign
#Double quotes keep special characters intact

#Another good habit
#Use braces to tell bash where a variable name ends
echo ${foo}bar		gets the name of var foo and appends string bar
			note that it is NOT {$foo}bar
eco $foobar		Gets the value of var foobar
#Good habit to use braces whereever there may be confusion

#Another very good tip
#In a script, use ${HOME} rather than ~  
#The tilde is not escaped in double-quotes

#Debugging
#The -x option
#!/bin/bash -x
#Prints out the contents of each evaluated line
#A real goodie

#But what  happens if you just want to debug a few lines
#In this case do not use -x on initial hash-bang line
#Use 
set -x 			On line above where you want debugging to start
set +x			On line below where you want debugging to end

#If Then Else
#From the command line
if mkdir a; then echo "ok"; else echo "error"; fi

#Most basic use of if statement
if testcode; then
	# Code here gets executed
	# when testcode succeeds
fi
#Most basic use of if-then-else
if testcode; then
	#code here gets executed
	#when testcode succeeds
else
	#code here is executed
	#when testcode fails
#Another example
if [[ $noteo ]]; then
	echo "Ok"
else
	echo "no note"
fi

# CAN put then on next line and leave out semi-colon
# but that is not common practice
# BUT 'else' and 'fi' are always on a new line
# because these keywords have to be the first word in command
# And also true, of course of 'if' and 'then'
# - these keywords must be the first in command

#On command line could write
# if testcode; then successcode; else failcode; fi

# In general, if, then, else and fi keywords
# need to be on a separate line
# or come after a semi-colon

#Return Codes
#When a Unix program finishes, it returns a number between 0 and 255
#called  a return code or exit status
#'0' means success
#All other values indicate an error

# Shell scripts return values with exit
exit 0 
#script will end and return success

#Good habit. Make sure your program exits with correct value
#Always call exit with a value

#if statement just looks at RETURN CODE for "testcode"

#Conditional Expressions

# A conditional expression
	# Tests on files and directories
	# Tests on string
	# Arithmetic tests

	[[ expression ]]

	#double-square-bracket
	#SPACE
	#expression
	#SPACE
	#double-square-brakcets

#Expression		True if
[[ $str ]]			str is  not empty
[[ $str = "something" ]]	str equals string "something"
				#note spaces around "equals-to"
[[ $str="something" ]]		always returns true!
[[ -e $filename ]]		file  $filename exists
[[ -d $dirname ]] 		$dirname is a directory

# Spaces around the expression are very important!
# Same for switches (-e) and equals sign

#create script ...

help test
#above pretty good on conditional expressions

#Conditional expressions
#Where does 'test' come from
#Historically, a classical command called 'test'
#Still remains for compatability
#aka as '['   (single square bracket) 
#since it is a normal shell command, it gets parsed normally
#everything you pass into it gets parsed like normal argument
#including expanding wildcards and command substitution
#hard to use, easier to make mistakes
#many pitfalls
#Advise DO NOT USE unless want to run program on non-bash shells

#[[...]] is a bash extension
#easier to use as two brackets are not actually a command
#but a special syntax
#everything that goes between the brackets gets parsed in special way
#NO QUOTES NEEDED AROUND VARIABLES
#Good habit: use [[...]] instead of [..]

#"help test" will give most important info
#"help [[" will tell you about the extension

#Arithmetic tests
#Can only compare numbers, as bash does not handle floating-points at all
#Syntax
#[[ arg1 OP arg2 ]]
#Where OP is
-eq		equal
-ne		not-equal
-lt		less-than
-gt		greater-than
others		see help

#Main Point: do not use 'normal' operators (=, <, >, etc) for numbers
#These work on STRINGS ONLY 

#Two special variables need to know about
$#		Contains the number of script arguments
$?		Exit status for the last command you ran
#In addition
#To get the length of the string in a variable, use:
${#var}
#The above is important, and a real goodie. 

# To count the number of files in directgory
ls -A1 | wc -l 

#Can nest if statements
#But can also use elif

if [[ $count_1 -gt $count_2 ]];then
	echo "${dir1} has more files"
elif [[$count_1 -eq $count_2 ]];then
	echo "number of files is equal"
else
	echo "${dir2} has more files"
fi
# Can use Multiple elifs

if [[ $1 = "cat" ]]; then
	echo "meow"
elif [[ $1 = "dog" ]];then
	echo "wooof"
elif [[s1 = "co2 ]]; then
	echo "moo"
else
	echo "unknown animal"
fi

#each elif gets tried in turn

#And, Or, Not
#In a  conditional expression
#use ! to negate a test
[[ ! -e $file ]]
#use spaces around '!'

#Use && for "and"
[[ $# -eq && $1 = "foo" ]]
#true if exatcly one arg with the value "foo"

#Use || for "or"   (two pipe symbols)
[[ $a || $b ]]
#true if a or b contains a value (or both)

#Helpful advise from Reindert
#Don't use -a, -o for and, or
#EVEN THOUGH "helo test" says so
#
#Input and Output

#ECHO
#prints its arguments to std output, followed by newline
-n		suppresses new lin
-e		allows the use of escape sequences
		\t	tab
		\b	backspace
#These options are NOT portable to non-bash shells
#and are generally discouraged

#For more sophisticated formatting, use printf
#Printf
#uses a format string for first argument
#will not append a new line at end of output by default

printf "hello"
printf "hello\n"
#Print a variable
printf "hello %s, how are you?\n" $USER
printf "p%s\n" a e i o u
printf "%ss home is in %s" $USER $HOME
printf "|%20s | %20s | %20s |\n" $(ls)
#printf can save output to variable
printf -v greeting "Hello %s, How are you?\n" $USER
echo $greeting
#see here for more on printf
http://wiki.bash-hackers.org/commands/builtin/printf

#Remember, with printf
-v		puts output to variable

#Read Revisited
 #Read puts input into a variable
read x
 #set user input to x
 #CAN choose not to set a variable name
 #value will end up in variabl called REPLY
 #options
-n		read a specific number of characters
		where 'read' will stop when it
		encounters a new line
-N		read a specific number of characters
		and will keep reading until the
		exact number of characters is read
-s		suppress output (useful for passwords)
-r		disallows escape sequences
		RECOMMENDED to always use -r with read
		It gives the raw input
#Read can also split your input into multiple words
#and assign each to a variable
read x y 	reads first word into variabl 'x'
		everything else into y
#if, say input "1 2 3", then x =1, y = "2 3"
#use IFS - Input Field Separator - for delimiters
read; echo $REPLY
read x y
echo $x
echo $y
#BUT BETTER
read -r; echo $REPLY
#This allows backslashes to be part of input 
#where escaping is unnecessary

IFS=: read a b
1:2
echo $a
echo $b
#IFS changed just for single command

#Standard Streams
#whenever a shellscript starts, it automaticaly connects
#with three standard streams:
Standard input, standard output, standard error
#When running a script from an interactive
#command-line terminal, these streams will
#connect with the terminal
#input will be sent to std in
#output will be sent to std out
#In Unix, these three streams are identified
#either by a number (file descriptor)  or a special file

# 0: Standard Input (stdin)
/dev/stdin

# 1: Standard Output (stdout)
/dev/stdout

# 2: Standard Error (stderr)
/dev/stderr
#used for diagnostic or error messages
#Normally won't notice, but it makes it 
#possible for to treat errors differently from
#other output

#Another special file
/dev/null
#disgards all data sent to it
#handy to hide command output
#simply redirect to /dev/null
#and output disappears
#/dev/null is aka the bit-bucket

#Redirection 1

#Bash offers syntax for redirecting the streams so
#that their data flows to or from another place
#In other words, can take input from a file
#or another command and send our output to a file
#or another command 

<		input redirection
		grep milk < shoppingnotes.txt
>		output redirection
		ls > listing.txt
>>		append to end of file

#finally, pipes
ls | grep x

#Redirection 2
 N>		Redirect to a specific stream
#mostly used to redirect errors to a file
cmd 2> /dev/null 	disgards all error messages
#2 is the error stream
#so all error messages from command will be disgarded

#N defaults to 1, so do not need to specify a
#number if you are redirecting standard output

#Can also redirect a stream into another stream 
>&N	Redirect a strem to another stream
#Put an ampersand and a number after the greater-than
>&2	Sends std output to std err 
	(equivalent to 1>&2)
2>&1	Send std err to std output
	(this would all you to log errors and std output
	to a single file)
cmd > logfile 2>&1 		takes output of command
				saves in logfile
				also sends all errors to std out
				since stdout points to logfile
				errors end up in same file
#Don't do this
cmd >logfile 2> logfile 	Two streams will over-write 
				each other's data 
#Bash offers two additional ways to point both streams to same file
&> 
>&
#Don't use above two!  They are considered deprecated
#Stick to the first option only

#Redirection is allowed anywhere on the command line
cmd < inputfile > outputfile
>outputfile cmd < inputfile
#Above two commands are equivalent
#These two are different
cmd > logfile 2>&1 		sends errors to logfile
2>&1 > logfile cmd		sends errors to stdout

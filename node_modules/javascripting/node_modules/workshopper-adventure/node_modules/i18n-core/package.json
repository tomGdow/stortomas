{
  "name": "i18n-core",
  "version": "2.1.1",
  "description": "Basic i18n translation.",
  "main": "index.js",
  "scripts": {
    "test": "lab -c"
  },
  "author": {
    "name": "Martin Heidegger",
    "email": "martin.heidegger@gmail.com"
  },
  "homepage": "https://github.com/martinheidegger/i18n-core",
  "bugs": {
    "url": "https://github.com/martinheidegger/i18n-core/issues"
  },
  "license": "ISC",
  "dependencies": {
    "mustache": "^0.8.2",
    "sprintf": "^0.1.4"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:martinheidegger/i18n-core.git"
  },
  "devDependencies": {
    "code": "^1.2.1",
    "lab": "^5.1.0",
    "mockery": "^1.4.0"
  },
  "readme": "# i18n-core\n\n[![Join the chat at https://gitter.im/martinheidegger/i18n-core](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/martinheidegger/i18n-core?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n[![Build Status](https://travis-ci.org/martinheidegger/i18n-core.svg)](https://travis-ci.org/martinheidegger/i18n-core)\n[![Code Climate](https://codeclimate.com/github/martinheidegger/i18n-core/badges/gpa.svg)](https://codeclimate.com/github/martinheidegger/i18n-core)\n\n[i18n-core](https://github.io/martinheidegger/i18n-core) is a no-fuzz Node.js implementation of i18n. It doesn't connect to express or any other fancy Node framework and is extensible where it needs to be and allows to reduce the complexity of other i18n implementations (thus the name).\n\nIt implements basic variable replacements in the mustache and sprintf manner.\n\n# Installation\n\nTo use *i18n-core* all you need to do is install it using ```npm```\n\n```bash\n$ npm i i18n-core --save\n```\n\n# Usage\n\n```JavaScript\nvar i18n_core = require(\"i18n-core\")\nvar i18n = i18n_core({greeting: \"hello!\"})\ni18n.__(\"greeting\") // hello!\n```\n\nTo have different namespaces for different languages you can get a prefixed subpart using `.lang()`.\n\n```JavaScript\n\nvar i18n = i18n_core({\n  en: { greeting: \"hello!\" },\n  de: { greeting: \"guten tag!\"}\n})\n\nvar en = i18n.lang(\"en\")\nen.__(\"greeting\") // hello!\n\nvar de = i18n.lang(\"de\")\nde.__(\"greeting\") // guten tag!\n```\n*Note: `.lang(<lang>)` is the same thing as `.sub(<lang> + \".\")`*\n\n## Lookups\n\nThe system is based on `lookup` implementations that allow the system to use different sources to get its strings from. The examples before used an object and because of this the former example would be equal to:\n\n```JavaScript\nvar i18n = i18n_core(require(\"i18n-core/lookup/object\")({greeting: \"hello!\"}))\n```\n\nIf you were to pass in a string to `i18n-core` instead like this:\n\n```JavaScript\nvar i18n = i18n_core(\"./\")\n```\n\nThen it would be equal the primitive **file-system** lookup same like this:\n\n```JavaScript\nvar i18n = i18n_core(require(\"i18n-core/lookup/fs\")(\"./\"))\n```\n\nYou can pass in your own strategy by given an object to the constructor that contains a \"get\"-method:\n\n```JavaScript\nvar i18n = i18n_core({\n    get: function (key) {\n        return null; // Who needs translation anyway?\n    }\n})\n```\n\nIn case you need to have several strategies that need to be chained you can use\nthe **chain lookup**:\n\n```JavaScript\nvar i18nChain = require(\"i18n-core/lookup/chain\")\nvar i18nObject = require(\"i18n-core/lookup/object\")\nvar i18n = i18n_core(i18nChain(i18nObject({a: \"x\"}), i18nObject({a: 0, b: 1})))\ni18n.__('a') // x\ni18n.__('b') // 1\n```\n\nIn case you have an `i18n` object that you want to use as lookup for another `i18` object you can **extend** them:\n\n```JavaScript\nvar i18nExtend = require(\"i18n-core/lookup/extend\")\nvar i18nObject = require(\"i18n-core/lookup/object\")\nvar i18nA = i18n({a: \"x\"})\nvar i18nB = i18n(i18nExtend(i18nA, i18nObject({\n    b: 1\n})))\n\ni18n.__('a') // x\ni18n.__('b') // 1\n```\n\n## Substitution\n\n*i18n-core* does implement basic placeholder replacements like:\n\n```JavaScript\nen.__(\"%s is cool\", \"he\"); // \"he is cool\"\n```\n\nfollowing the logic of [sprintf](https://github.com/maritz/node-sprintf).\n\nIt also offers [mustache](https://github.com/janl/mustache.js) pattern replacement like this:\n\n```JavaScript\nen.__(\"{{name}} are cool too\", {name: \"you\"}); // \"you are cool too\"\n```\n\n\n## Advanced Namespaces\n\nIt is possible to chain translation prefixes like this:\n\n```JavaScript\nvar at = i18n_core({de:{at: {hello: \"Zewas!\"}}}).lang(\"de\").lang(\"at\");\nat.__(\"hello\") // Zewas!\n```\n\nand you can also change the chain if you want to.\n\n```JavaScript\nvar translate = i18n_core({\n    de: {title: \"Meine Webseite\"},\n    en: {title: \"My Website\"}\n}).lang(\"de\", true) // <- this true is important :)\ntranslate.__(\"title\") // Meine Website\ntranslate.changeLang(\"en\")\ntranslate.__(\"title\") // My Website\n```\n\nTo prevent malicious use the changing of the language is prevented unless you pass a `true` flag to it.\n\nIn some instances it is necessary to know in advance if a key has a value or not, in this case you can use `has`.\n\n```JavaScript\nvar translate = i18n_core({title: \"My Website\"})\ntranslate.has(\"title\") // true\ntranslate.has(\"subtitle\") // false\n```\n\nAdditionally, for module development, its possible to access the raw data using `raw`:\n\n```JavaScript\nvar translate = i18n_core({no: {val: 5}})\ntranslate.raw(\"no\") // {val: 5}\n```\n\n## Outro\n\nIf you have any questions, please post them as issue, thanks!\n",
  "readmeFilename": "Readme.md",
  "_id": "i18n-core@2.1.1",
  "dist": {
    "shasum": "f98feaa5c2d8844c6b54a7fab0001fd056b6d766"
  },
  "_from": "i18n-core@^2.1.1",
  "_resolved": "https://registry.npmjs.org/i18n-core/-/i18n-core-2.1.1.tgz"
}

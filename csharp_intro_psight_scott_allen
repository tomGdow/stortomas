                                    # Intro
# .net is separate from visual studio. Most releases of Windows already 
# have .net installed
# You build you apps on top of .net framwork, which consists of
#1 Common Language Runtime (CLR)
#2 Microsoft .NET
#3 Framework Class Library (CLR)

#Windows Server 2012 will also have .net framwork installed. 

# What is CLR?
# The CLR is an execution environment for your .net applications. 
# It is the CLR that manages your application.
# Some of the services provided by CLR
# Memory management
# CLR is like a VM, like the Java JVM, the Java VM
# Dont have to worry about OS or type of CPU
# Common languages: C-sharp, F-sharp, Python, Visual basic.
# CLR available for every version of  Windows since Windows XP

# FCL
# A library of functionality to build applications
# This is what is used on a day-to-day basis.
# BCL is the base class library.  Works everywhere. 
# Another part of the FCL is ASP.net, and asp.net applications
# run on a web server rather than the desktop, and uses all
# use a web browser. 
# Windows Communication Foundation (WCF). All computers to 
# communicate directly and exchange data. 
# Typically, no-one is master of all FCL but one becomes
# maybe an expert in one area such as ASP.net. 

#C# 
# Reusable code that can be used my many appications.  A class library. 
# C# syntax was inspired by C++, 
# so C# is similar in syntax to Java, C++ and JavaScript (sic) 

public static void Main () 
{
  if (DateTime.Now.DaysOfWeek == DayOfWeek.Monday)
  {
      Console.WriteLine("Another case of the Mondays!");
  } 

}

# Defines a method called Main
# used DateTime class 
# uses Console class, also part of FCL 
# C# is a compiled language.
# Create hello.cs
# Save ..
# C:\Users\Thomas\Documents>c:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe hello.cs
# hello.exe

# The compiler
# The C# compiler transforms C# code into Microsofte Intermediate Language
# MISL
# file.css => csc.exe => myapp.exe
# CLR takes the Intermediate Language Instructions and translates them
# into native instructions that can be used by the CPU. 

# Hello, Visual Studio 
# From VS
# File -> New Program -> Visual C# -> Console Application
# Console apps can be run from command line

# Editing C#
# In debugger, F10 steps over code.
# In C#, types are very important. C# is a strongly typed language. 
# Write a class to create a new type.
# Console.is a type, and call WriteLine (but not Print) 
# FCL does NOT provide Classes and Types specific to the problem we are trying to solve.
# Primitive types such as int (Integer), long (Long Integer), DateTime (Date and Time Value)

                                 #Classes in C#
# We need an electronics grade book to read the scores of an individual student 
# and then compute some simple statistics from the scores.

# The grades are entered as floating-point numbers from 0 to 100, and the 
# statistics should show the highest grade, the lowest grade, and the avarage grade. 
# Create a class to make an abstraction of an NOUN. Grade book is a noun. 

# Most c-sharp developers will put each class in its own file. 

# Class Members fall broadly into two classes.
#1 State
#2 Behaviour
# State is the data you need to work with. 
# State for gradebook is the grades that are being entered for student.
# Behaviour is typically methods that do work. 
# Two c-sharp keywords: public and void. Will be discussed later. 
# Say addAGrade, or compute statistics. 
# Classes define a new type. 
# Classes are one way to define a type.
# Can use a class to instantiate one or more objects
# It is objects that I need to work with in my program. 
# It is objects that are allocated into memory of computer
# and it is objects that hold the data that I need. 
# Think of a class definition as a blueprint for creating objects of that type. 
# Think of it as a cookie-cutter. The CLR will use my gradebook cookie-cutter to
# create new cookies with the shape of a gradebook, and the dough that it is using
# is the memory of the computer.  
# Ctrl-F5 to run program without debugger. 
# Constructors
# Special methods used to initialize objects
GradeBook  book = new GradeBook();
#When I use the new keyword followed by the name of
# a class with parentheses, I am instantiating an 
# instance of a class. It is creating an object.
# Creating an object will invoke a special method we call
# a constructor. A consructor  helps to construct an object. 
# Every class will have a defaut contstructor that exists 
# implicitly unless I do something special. 
# This is why I can create an instance of GradeBook
# that works, that is that gives me an object, even
# though I do not have a constructor explicitly defined 
# inside GradeBook.
# If I do define a constructor, it is very much like
# defining a method. 
public GradeBook () 

{
        // ... initialization code
}

# I'll use the public keyword again
# void not necessary
# after public keyword, define a method where the method name
# is the same as the class.  As with method will have 
# parentheses, which will take argumentts if you want. 
# Also has curly braces to denote start and end of the method.
# There are many situations where you will want to write your
# own constructor, or multiple constructors, for a class. 
# Allows fine control ...
ctor # // Press Tab twice
# recognised as code snippet in Visual Studio 

# Classes versus Variables
# A class is a blueprint for creating objects
# Objects created from Classes with 'new' keyword
# a class can also be used to type a variable
GradeBook book;
# a variable can refer to any object of the same type
# You can think of a variable as a storage location
# that points to a specific object. 

Gradebook book = new GradeBook();

# Instantiating an instance of the GradeBook class
# referring to the new object that is being created
# through the book variable of type Gradebook 
# More than one variable may point to a single object
# When an object is not referred to by variable anymore (say
# overwritten) exists in memory but cannot refer to it anymore.
# Garbage collector will take care of that. 
#Common language runtime is smart enough to periodically scan
#throught memory, figure out which objects are garbage because
#they are not referred to by any variables in the program,
#and can clean those object up, thus freeing up memory. 
#Reference Types
# When we create a class in c#, we are creating a type,
# specifically we are creating a reference type. 
# Reference types are one category of types in c-sharp.
# Classes are reference types. 
# When we have a variable that is typed as a class like GradeBook,
# a reference type,  we have a storage location in memory
# to remember the Gradebook, but it is incredibly important to 
# understand that the storage location dedicated to a variable,
# like a variable called 'book1', DOES MOT hold the GradeBook 
# itself.. that is NOT where the GradeBook is stored. The
# GradeBook is stored somewhere else im memory, and the
# storage location of the variable holds a pointer to that
# object in memory.  The variable literally contains
# a memory address. It is like when someone gives you their7
# business card. You don't hold the other person, you hold
# a pointer or address to the business. 
# part of indirection in software. 
# One implication is that I can have multiple
# variables (all of type GradeBook) all pointing to 
# the same object. 
# OOP
# Encapsulation
# VisualStudio. Ctrl-period to create a methods stub. 
# void keyword: no return value
# Access Modifiers
# Encapsulation is the ability to hide or group related concepts
# access modifiers are keywords like 'public' and 'private' 
# that describe who is allowed to access certain fields and methods. 
# Important when want to hide something from other programmers,
# and make your classes easier to work with. 
# For example, GradeBook keeps around a list of grades being entered.
# The list of grades is private, meaning there is no access to the
# list of grades from outside the GradeBook 
# ONLY THE CODE INSIDE THE GRADEBOOK can inspect and
# modify the list, so grades are completly encapsulated inside
# the GradeBook
# Gradebook also has methods such as AddGrade and ComputeStatistics
# that use the 'public' keyword. 
# These methods are publicly available, meaning anyone 
# who has a variable pointing to a GradeBook object can access
# these methods and invoke them. The methods still provide some
# encapsulation in that we do not need to see what code is inside
# the methods, but the methods themselves are public and open to
# everyone. 
# 'public' and 'private' are just two access modifiers. 
# A constructor does not have a return type (void is a return type) 
# Statics
# Use static members of a class without creating an instance
# Members of a class may be marked as static. 
public static float MinimumGrade = 0;
public static float MaximumGrade = 100;
# Other examples
Console.WriteLine("Hello!");
# Generally speaking, to do any useful work with a Class
# you need to use the 'new' keyword to call a constructor
# and create an instance of that Class, but there are classes
# out there with static members that can do work without creating
# an instance of that Class. Instead you reference a static
# field or static method using the Class name followed
# by a dot followed by name of the static field or method
# you want to access. For example:  
Console.WriteLine(GradeBook.MaximumGrade);
# This is also how Console.WriteLine works. Console is a
# Class, but I do not need to create an instance of Console ...
# It has static methods like WriteLine that I can invoke, 
# as above. 
# Be careful  with statics! 

                             # Types and Assemblies 

# Every c# type falls into one of two categories
#1 Reference type
#2 Value type
# Will also see how types are packaged into files called assemblies. 

# Reference Types
# Reference types in c# are types creaged from Class definitions
# like the GradeBook created in the last module.  Anytime I 
# create a new Class, I am creating a new reference type. 
# Variables hold a reference to an object
# Multiple variables can point to the same object 

#public members we expose from a Class, start with a capital letter.

# In reference types, variables POINT to objects that are allocated in memory. 

#2 Value Types. 
# Variables hold the value. 
# No Pointers.  No references. 
# Does not hold a memory address
# For example, integers and floats are value types in .NET 
# If I have a variable y of type int or int32 (synonyms) and I assign
# this variable a value of 4, then the value 4 is literally stored
# inside the memory location of variable y.  It is no longer a pointer to an object in memory. 
# The value is wholly inside that variable. 
# If y = 4 and I say x = y, we
# take a copy y and put it into x.  Now both x and y hold the value 4.
# Value types exist because they are generally faster to allocate than reference types.
# Creating an Object is more expensive than creating a value. 
# Most primitive types in .NET are value types. 
# Value types are immutable. 
# How do we create a value type? That is where the keyword 'struct' comes in ...
# Method Parameters. 
# In C#,  parameters pass 'by value' by default 
# This means that when you call a method that takes a parameter, by default
# the value that you have in your variable that is passed to the method is
# GOING TO BE COPIED into the variable that is a parameter to a method, unless
# you add some additional keywords.
# However, keywords almost never used. 
# This means for reference types, you are passing a copy of a reference, or
# a copy of a pointer to an object. 
# But when you pass a variable of value type to a method, you are passing a copy
# of that value.
# There are two keywords that may be used to change 'pass by value' behaviour.
# These should be used very sparingly. 
static void GiveBookAName(ref GradeBook book) 
# Now pass BY REFERENCE
GiveBookAName(ref g2); 
#The other keyword is 'out'
# Pretty much the same as ref, with one little difference
# ref assumes that the variable being passed in has
# already been initialized, and it does not need to
# assign anything to it. 
# out can take an uninitialized variable, but MUST make
# an assignment. 
# There is usually a better way than 'ref' and 'out'.

# Struts and Enums
# Creating Value types.
# struct definitions create value types. 
public strut DateTime 
{
  // ...
}
# A struct definition looks just like a Class definition ...
# It has a name, and opening/closing curly-braces.
# Everything inside curly braces a member of the structure. 
# How do I decide whether to write a class or a struct?
# General rule-of-thumb is write a class by default. 
# Structs are meant for special cases where you 
# want to write an abstraction that represents a single value.
# A DateTime, for example, represets a single value 
# Represents something we can reason about as a single value
# Structs do best when they contain a small amount of data. 
# They will be copied frequently, for example. 

# Another way to create a value-type in c# is to 
# create an enum. 
# An enum creates a type that can only contain specific 
# numerical values. 
# An enum, short for enumeration, is a good way
# to create named constants in your software
# So istead of using 1 or 4 or whatever in code can use
# PayrollType.Hourly (instead of '1'). 
public enum PayrollType 
{
    Contractor = 1,
    Salaried,
    Executive,
    Hourly
}

# For example
if (employee.Role == PayroleType.Hourly) 
{
    // ...
}

#F12 Go to Definition.  Useful to tell if dealing with a ref
# type or  a value type.  
# Classes are always ref types
# structs are always value types
StringComparison 
# is a built-in enumeration. 

# Immutability
# One special behaviour of value types is that
# value types are typically immutable. 
# Primitive types provided by Microsoft are all immutable
# This means that once create value type cannot change. 
# You CAN of course chane the value you are storing in a
# variable (that's why they are called 'variables') but 
# the actual value can never change. 
# Cannot change value of 4
# Cannot change the value of August 9th, 2002.
# Two common errors new C# developers frequently run into.
# DateTime 
# StringType

DateTime date = newDateTime (2002, 9, 11);
date.AddDays(1)

#LOOKS like can add 1 day to date ...
# but AddDays will never change the underlying value 
# that is inside my variable. 
# Instead what it will do is return a new DateTime value!

string name = " Scott ";
name .Trim();
# What is interesting about a string is that it is a REFERENCE
# TYPE. Don't let anyone tell you any different. 
# When you are working with strings you have a reference
# that points to a sequence of characters. That makes it 
# easy to pass strings around to different methods. Because
# we pass a reference instead of passing the entire string. 
# So string is a reference type, but it behaves like a value
# type in many, many ways. One way is that is string is 
# immutable. Once you have constructed a string, you cannot
# change that string value. 
# Let's consider 'Trim'
# What 'Trim' will do is remove the leading and trailing
# whitespace.
# It does not to that by modifiying the string I am pointing at:
# instead it creates a new string with the characters removed. 

# Arrays
# Manage a collection of variables. 
# The array is ALWAYS a reference type. 
# Arrays, unlike list, have a fixed size. 
# Must specify size of array, and that size cannot be changed. 
# Always zero indexed. 
# We are using a list in GradeBook, rather than an array, because we do not 
# know how many grades are going to be stored. 
# A list will grow automatically, and grab the space necessary to hold new items. 
# This is POSSIBLE with array, but much more difficult. 
# One thing that an array and a list have in commmon is that they are both 
# zero-indexed.
# To declare an array
const int numberOfStudents =4;
int[] scores = new int[numberOfStudents]
int totalScore = 0;
foreeach(int score in scores) 
{
    totalScore += score;
}

double averageScore = (double)totalScore / scores.lengh;
# Can only store integer values
# Can only contain four values
# Assemblies
# Assemblies are .exe or .dll files
# Contain metadata about all files inside 
# Cannot leave this module without talking about the relationship between
# types and assemblies, because all of the types we create, both ref types
# and value types, all have to be packaged into an assembly in order for the 
# code to execute or be used for other programs. 
# Assemblies are just files with the .exe or .dll extension. They are
# produced in Visual Studio program from the C# compiler.  
# If you want to share, say the GradeBook with other people can
# 1 Give them the source code and they can build their own assembly
# 2 Give them a copy of the assembly itself. 

# In fact Microsoft does option 2.  All of built-in types we have been 
# looking at: integers, DateTime, strings,  lists, arrays ... 
# all of the code for these types live in assemblies that Microsoft has
# authored. 
# Because they are used by every .NET program on a machine, 
# Microsoft puts many of these .NET core assemblies into a location on 
# your machine known as the 
# Global Assembly Cache,
# which is a central location to store assemblies for a machine. 
# By default GAC is underneath Windows directory in a folder called assembly
# C:/Windows/assembly 
# Must load assembly into memory before using types inside. 
# Easy approach - Reference the assembly in Visual Studio 
# See References node within Solution Explorer
# Contains a list of all the assemblies that the project is using. 
# Can remove assemblies if unused.  
# But cannot remove mscorlib 
# If want to add a reference ...
# Right-click on 'References'
# => Add Reference
# -> Dialog Box ...
# -> Search for Speech 
# -> Add

# Test Yourself
# Unit tests ...
# A Visual Studio Solution can have multiple projects inside of it...

# Methods, Events and Properties in C# 

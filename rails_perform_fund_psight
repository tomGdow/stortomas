# Rails Performance Fundamentals
# Pluralsight
# Brian Morearty

# What is performance as opposed to throughput,
# as opposed to scalability?

#  Performance: The speed of one user's experience
#  (not PERCEIVED performance)
#  perceived performance -not a topic of this course -
# is using tricks to make the user be less anxious while
# waiting for something to finish.   Showing a spinner is
# when something is loading, is a good example. The user knows
# that something is going on. Yes, the system IS working 

# Apache ab
 ab http://localhost:3000/teachers
# To average over 10 requests
ab -n10 http://localhost:3000/

#Sometimes see 5-10 ms connection time.
# Dont really want this when testing on localhost
# All you care about is server speed, not connection time
# Can tell apache bench to keep connection alive
# across requests with '-k' option

ab -n10 -k http://localhost:3000/

#Simple Ways to See Server Side Performance

#1 x-Runtime HTTP response header (Rack::Runtime)

# When all you want to know is how much time
# was spend in serving this page by itself without
# the images
	# 1 Open Browser developer panel (Chrome)
	# 2 Go to nework tab
	# 3 'Hit' (refresh) the page
	# 4  Click on 'localhost'
	# 5 Select 'header' sub-menu
	# 6 Look in response for x-runtime
	# This header (x-runtime) is inserted by Rack runtime middleware
	# Number is measured in SECONDS not milliseconds
	# Ruby(x-runtime)  plugin for Chrome gives identical answer

#2 Browser Debug panels

# Latency. Doesn't always mean the same thing.
# Used by Chrome (and Firefox?) to mean the amount of
# time between finishing sending the request and
# getting the first byte of the response
# aka 'Waiting (TTFB)'  - 'Time to first byte'

# The other use of 'latency' is to describe
# the overhead of the connection.  This is 
# called 'network latency'. It includes 
# things like the time for a cellphone to 
# negociate a handshake with a radio tower, 
# time for a newwork switch to route the traffic
# correctly, and even the speed of light. That's why
# web request to servers on far away continents are
# slower. The speed of light can add to network
# latency even though it does not affect bandwidth.

# Newwork latency does not include time spend on a server

#3 Rails log at end of rendering response
# can show
				# 1 Total time spend in active record, views, partials
				# 2 Too many db calls
				# 3 Time spend in each db call

#4  Pagination
# Use kaminari gem for pagination
# Go to gemfile
# gem 'kaminari'
# bundle install
# home controller
def index
	@courses = Course.order(:created_at).page(params[:page]) 
end
# Kaminari takes two options	
					# page		(which page to show) 
					#  				(ONE-based, not ZERO-based)
					# per     (defaults to 25)
# Now got to view
<%= paginate @courses %>

#5 Indices
# Should index db columns that will be used for lookup and sort
# ALWAYS INDEX your foreign keys (_id columns) when creating migrations
# Rails follows the convention that all foreign key end with '_id'
# Good habit. Instead of
rails g migration AddTeacherToCourse teacher_id:integer
#do one of the following
rails g migration AddTeacherToCourse teacher:belongs_to
rails g migration AddTeacherToCourse teacher:references
# 'belongs_to' and 'references' are aliases of each other
# add teacher_id colum, but ALSO index
# BUT if write out columns in migration file
# 'belongs_to'  and 'references' DO NOT automatically 
# generate an index, but the rails GENERATOR knows
# it should automatically generate an index

# may also need to generate composite indices
# - a single index that combines multiple columns
# can use SQL EXPLAIN to see what index is being used.
# He does not explain ...
# but a nice little tool that looks for foreign keys
# that have not been indexed is 
lol_dba gem
# An excellent gem!! 

# Bullet gem
# Identifies N+1 Queries (missing eager loading)
# Identifies unused eager loading
# Identifies missing counter cashes
# N + 1 Queries
# Say listing all courses for currently logged-in user
# Controller may look like this
@courses = current_user.courses
# In views, iterate over, getting somthing from each thing
<% @ courses.each do |course| %>
<div><%= course.name %></div>
<div><%= course.teacher.name %></div>
<% end %>
#course.teacher is another query EXCEPT doing that once per
#course. So if there are N courses, doing N queries to get teachers.
#Add this to the one query for courses - "N+1" query.  

# In Rails, the solution is to use eager loading with ".includes"

@courses = current_user.courses.includes(:teacher)

#Counter-caches
# Similar to eager loading, except that instead of retrieving
# another record for every record in the main list, you
# are retrieving a count of associated objects in the 
# main list

# Showing the teacher's name for each class is an 'N+1' problem
# Showing the number of students in each class is also an 'N+1' problem,
# except it is solved differently. It is solved with counter-cache.
# Bullet helps find

# Add bullet to Gemfile (development only)
bundle install

# Go into development.rb, add the following
config.after_initialize do
	Bullet.enable = true
	Bullet.alert = ENV['BULLET_ALERTS']
	Bullet.bullet_logger = true
	Bullet.console = true
	Bullet.rails_logger = true 
end

# 2min 40secs into 'Bullet, N+1 queries ...!
# On top of development.rb, set ..
 config.cache_classes = true
 #This gives more realistic timing
 BULLET_ALERTS = true rails s
# To fix, go to 'home' controller
#  Change
 @courses = Course.order(:id).page(params[:page])
 # to
 @courses = Course.order(:id).page(params[:page]).includes(:teacher)

# now no error and from log

Completed 200 OK in 5103ms
#(Pluralsight get 93 ms)!!
# This is key line ... 
SELECT "teachers".* FROM "teachers"  WHERE "teachers"."id" IN (196, 89, 99, 281, 181)
# ie eager loading of teacher id from courses

# Now counter cache that bullet still telling .. 
# Modified eager loading to the following, now down to 461 ms
 @courses = Course.order(:id).page(params[:page]).includes(:teacher).select(:id, :name, :teacher_id, :enrollments_count)
#Stopped here to go over to skketpics and install bullit

# He uses DIRECT SQL to implement counter caches (Railscast does the same) for speed considerations


# Rack Mini Profiler
gem 'rack-mini-profiler'

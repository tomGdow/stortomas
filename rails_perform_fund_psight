# Rails Performance Fundamentals
# o0
# )oGG
# Pluralsight
# Brian Morearty

# What is performance as opposed to throughput,
# as opposed to scalability?

#  Performance: The speed of one user's experience
#  (not PERCEIVED performance)
#  perceived performance -not a topic of this course -
# is using tricks to make the user be less anxious while
# waiting for something to finish.   Showing a spinner is
# when something is loading, is a good example. The user knows
# that something is going on. Yes, the system IS working 

# Apache ab
 ab http://localhost:3000/teachers
# To average over 10 requests
ab -n10 http://localhost:3000/

#Sometimes see 5-10 ms connection time.
# Dont really want this when testing on localhost
# All you care about is server speed, not connection time
# Can tell apache bench to keep connection alive
# across requests with '-k' option

ab -n10 -k http://localhost:3000/

#Simple Ways to See Server Side Performance

#1 x-Runtime HTTP response header (Rack::Runtime)

# When all you want to know is how much time
# was spend in serving this page by itself without
# the images
	# 1 Open Browser developer panel (Chrome)
	# 2 Go to nework tab
	# 3 'Hit' (refresh) the page
	# 4  Click on 'localhost'
	# 5 Select 'header' sub-menu
	# 6 Look in response for x-runtime
	# This header (x-runtime) is inserted by Rack runtime middleware
	# Number is measured in SECONDS not milliseconds
	# Ruby(x-runtime)  plugin for Chrome gives identical answer

#2 Browser Debug panels

# Latency. Doesn't always mean the same thing.
# Used by Chrome (and Firefox?) to mean the amount of
# time between finishing sending the request and
# getting the first byte of the response
# aka 'Waiting (TTFB)'  - 'Time to first byte'

# The other use of 'latency' is to describe
# the overhead of the connection.  This is 
# called 'network latency'. It includes 
# things like the time for a cellphone to 
# negociate a handshake with a radio tower, 
# time for a newwork switch to route the traffic
# correctly, and even the speed of light. That's why
# web request to servers on far away continents are
# slower. The speed of light can add to network
# latency even though it does not affect bandwidth.

# Newwork latency does not include time spend on a server

#3 Rails log at end of rendering response
# can show
				# 1 Total time spend in active record, views, partials
				# 2 Too many db calls
				# 3 Time spend in each db call

#4  Pagination
# Use kaminari gem for pagination
# Go to gemfile
# gem 'kaminari'
# bundle install
# home controller
def index
	@courses = Course.order(:created_at).page(params[:page]) 
end
# Kaminari takes two options	
					# page		(which page to show) 
					#  				(ONE-based, not ZERO-based)
					# per     (defaults to 25)
# Now got to view
<%= paginate @courses %>

#5 Indices
# Should index db columns that will be used for lookup and sort
# ALWAYS INDEX your foreign keys (_id columns) when creating migrations
# Rails follows the convention that all foreign key end with '_id'
# Good habit. Instead of
rails g migration AddTeacherToCourse teacher_id:integer
#do one of the following
rails g migration AddTeacherToCourse teacher:belongs_to
rails g migration AddTeacherToCourse teacher:references
# 'belongs_to' and 'references' are aliases of each other
# add teacher_id colum, but ALSO index
# BUT if write out columns in migration file
# 'belongs_to'  and 'references' DO NOT automatically 
# generate an index, but the rails GENERATOR knows
# it should automatically generate an index

# may also need to generate composite indices
# - a single index that combines multiple columns
# can use SQL EXPLAIN to see what index is being used.
# He does not explain ...
# but a nice little tool that looks for foreign keys
# that have not been indexed is 
lol_dba gem
# An excellent gem!! 

# Bullet gem
# Identifies N+1 Queries (missing eager loading)
# Identifies unused eager loading
# Identifies missing counter cashes
# N + 1 Queries
# Say listing all courses for currently logged-in user
# Controller may look like this
@courses = current_user.courses
# In views, iterate over, getting somthing from each thing
<% @ courses.each do |course| %>
<div><%= course.name %></div>
<div><%= course.teacher.name %></div>
<% end %>
#course.teacher is another query EXCEPT doing that once per
#course. So if there are N courses, doing N queries to get teachers.
#Add this to the one query for courses - "N+1" query.  

# In Rails, the solution is to use eager loading with ".includes"

@courses = current_user.courses.includes(:teacher)

#Counter-caches
# Similar to eager loading, except that instead of retrieving
# another record for every record in the main list, you
# are retrieving a count of associated objects in the 
# main list

# Showing the teacher's name for each class is an 'N+1' problem
# Showing the number of students in each class is also an 'N+1' problem,
# except it is solved differently. It is solved with counter-cache.
# Bullet helps find

# Add bullet to Gemfile (development only)
bundle install

# Go into development.rb, add the following
config.after_initialize do
	Bullet.enable = true
	Bullet.alert = ENV['BULLET_ALERTS']
	Bullet.bullet_logger = true
	Bullet.console = true
	Bullet.rails_logger = true 
end

# 2min 40secs into 'Bullet, N+1 queries ...!
# On top of development.rb, set ..
 config.cache_classes = true
 #This gives more realistic timing
 BULLET_ALERTS = true rails s
# To fix, go to 'home' controller
#  Change
 @courses = Course.order(:id).page(params[:page])
 # to
 @courses = Course.order(:id).page(params[:page]).includes(:teacher)

# now no error and from log

Completed 200 OK in 5103ms
#(Pluralsight get 93 ms)!!
# This is key line ... 
SELECT "teachers".* FROM "teachers"  WHERE "teachers"."id" IN (196, 89, 99, 281, 181)
# ie eager loading of teacher id from courses

# Now counter cache that bullet still telling .. 
# Modified eager loading to the following, now down to 461 ms
 @courses = Course.order(:id).page(params[:page]).includes(:teacher).select(:id, :name, :teacher_id, :enrollments_count)
#Stopped here to go over to skketpics and install bullit

# He uses DIRECT SQL to implement counter caches (Railscast does the same) for speed considerations


# Rack Mini Profiler
gem 'rack-mini-profiler'
# Does not work with sqlite?
# add to Gemfile
# Should work with heroku?
# Flame graphs are another wonderful feature of Rack Mini profiler
gem 'rack-mini-profiler'
gem 'flamegraph'

#add 
?pp=flamgraph
#to end of url
# Look for long sections that are doing the same thing

# Select and Pluck
# Don't select un-needed columns from db
# You are transferring unneeded data
# use select
# Example

@courses = Course.order(:created_at).page(params[:page]).includes(:teacher)
.select(:id, :name, :teacher_id, :enrollments_count)

# Use select to remove large columns

# 'pluck' is similar to select in that it selects only the columns
# you specify. 
# But the difference that makes 'pluck' much faster is that 
# IT DOES NOT BOTHER TO CONSTRUCT ACTIVE RECORD OBJECTS.
# Instead returns an array of plain ruby values
# In Rails 4.1 can pluck a single column or multiple columns

Student.pluck(:id)  # => [1, 2, 3 ...]

# If you pluck multiple columns, you get back
# array-of-arrays

Student.pluck(:id, :name) # => [[1, "Brian"], [2, "Kathleen"], ...]

# Examples of where pluck may be useful
# API that returns data in CSV format
# Getting a list of ids

# If you are using something like the following
Student.all.map(&:name)		# Slower
Student.pluck(:name)			# Faster

														# The Rails Query Cache

# One super nice feature of Rails that gives you improved performance
# for free is the query cache.  
# Worth mentioning even though you don't have to do anything to get it
# If you know about it, can avoid doing optimizations Rails is doing
# for you. 
# Basic idea is that Rails caches identical SQL queries in memory
# If may the same query at any point while handling the same
# HTTP request, the query cache intercepts it and pervents a db call
# If at any time during that HTTP request, you make a call that
# writes to the database, the cache gets busted. 
# Cache also busted when request finished. 
# This is intentional. Query cache does short-term caching during
# the scope of handling a single request 
# Not stored in memcache-d.  Only available to a single request.

#key
#Whenever you seed the word 'CACHE' in all uppercase in Rails log
#that's query cache doing it's job.


																	#1  New Relic
#Popular SaaS performance tool for use in production 
# Has free plan, but paid plan better

# With Heroku free tier, added bonus
# Can use free-plan on New Relic to keep Heroku app alive
# and prevent 'swapping out'
# Go to Heroku dashboard (after install of new relic!) and
# hit 'new relic' link 
# How to get up the 'bonus item'
# How to use NR to keep Herou alive
# Go to NR settings -> availability monitoring -> use ping feature
# 'pings' site ever few minutes to see fi still alive
#

																	#2  Rails Panel
# This is a Chrome Plugin 
# AND go to gemfile and add 
gem 'meta-request'

# Don't order by 'created_at'
# Created-at column not indexed by default
# COULD add index on created-at
# but why not order by id instead?

																# Two final tips
#1  If making multiple writes, use a transaction!
# if have multiple saves in your own code, put a transaction
# block around it.  Db works hard after every commit

#2 If iterating over a lot of rows, use find_each 
# each has to load all those rows into memory
# find-each loads in batches (1000 by default)
# trade off is that find_each is slightly slower
# BUT uses less memory

# Here is a goodie for memory management checking

ps -o pid,rss,vsz,command

																		#Summary
# TOOlS
	# 1 X-runtime is a HTTP header that Rack middleware insert
	# into the response. If you don't want deep insight into
	# why a page is slow, x-runtime is sufficient
	# Shows how much time spend on server handling request
	# If you want to find out if problem on server-side or client-side

	# 2 Browser'rs network debug panel
	# 3 Rails log
	# 4 SQL explain statement and lol_dba: find missing indexes
	# 5 Bullet (N+1 query problems, counter-cache, eager-loading)
	# 6 Rack Mini-profiler
	# 7 Flamegraphs
	# 8 New Relic
	# 9 Rails Panel for Chrome Browser 

# TECHNIQUES
	# 1 Pagination (Kaminari)
	# 2 Add indexes for all foreign keys.
	# 3 Use '.includes' to fix N+1 queries with eager loading
	# 4 Counter caches help when need to count the numebr of obj in relation
	# 5 Select only columns that you use
	# 6 pluck only columns you use (without active record)
	# 7 Order by :id, not :created_at
	# 8 Multiple writes? Use a transaction if your code is doing a single save
	# 9 Iterating over tons of rows? Use 'find_each'  instead of 'each'
	#   Uses far less memory as retrieves records in batches of 1000
	#   Slightly slower, but BIG payoff

# YOU GET FOR FREE
	# 1  Rails Query Cache

# Next module is Browser Caching 
      -------------

															 # Browser Caching 
# If read books such as 'Faster Websites' or 'Even Faster Websites'
# by Steve Souders, you will see that speeding up the Client side 
# rather than the Server-side usually has a bigger impact on website
# performance

#HTTP HEADERS
	# We will cover five in total.  Presented in order of response /request
	# Looks as if backwards, but makes sense (NOT request/response)

	# 1 Last Modified (Server-to Client)	/ If modified since 
	#  (Client-to Server)
	# 2 Etag (Server-to Client)	/ If-None-Match (Client-to Server)
	# 3 Cache Control (Server-to Client)	(No corresponding request header)

	# That's five!
	# Note that these headers are only used for GET requests.
	# 'If Modified Since' and 'If None Match' headers are frequently
	# referred to as 'Conditional Get Headers'

	# Each header is associated with a SPECIFIC url.  
	# They are NOT global setting for a whole domain.

											#1  Last Modified / If-Modified-Since

# App can send Last_Modified Header in Response.  This tell browser
# when the resource was last changed. 
# In subsequent requests, the browser includes 'If-Modified-Since'  header,
# passing in the time-stamp it was given in the 'Most-Recent'  response header.  This allows the server to know whether to send back a '200 OK' response with a full HTML body in case where the resource is newer than what the browser last saw, or just to send a 304 not modified response with an empty body because it sees nothing has changed since the browser last saw it, so the browser is free to use its cache. 

# By sending 'If modified If' the browser is asking "Is the resource newer tthan the last time I saw it?" and, of course, "If it is newer, give me the full unmodified resource"

# Pros
#1 Reduces response bandwidth
#2 You control when the browser uses its cache
#3 Reduces sever load (but not automatically) 

# Cons
#1 Browser sends a response every time.  Browser cannot decide on its own
# what to use in its cache.  It has to delegate that decision to the server

											#2 ETag / If-None-Match

# Similar to 'Last Modified/If-Modified-Since, but with a subtle difference:# Instead if the content is NEWER, it checks if the content is DIFFERENT
# The app can send an e-tag header in response.  This is literally any string you want. Its chosen by the application. For example, it could be verion number. In Rails, typically a hashed digest of some information, such as body content (that you choose) 
# In a subsequent request, the browser sends a "If-None-Match' Header passing in the e-tag that was given in the most recent e-tag response header. Allows the server to know whether to send back a '200-OK' response with a full HTML body, or a 304 not-modified response with an empty body. 
# By sending "If-None-Match" the browser is asking "Is the resource DIFFERENT from the last time I saw it?"
# Sometimes timestamp may not change, but want to render something different anyway. eg. message all users. 

# More or less the same pros and cons as (1). 

# Reason both are allowed is that it is sometimes easier to use one or the other.

											#3  Cache Control

# Sometimes require to send additional caching info for browser
# about how it should cache response.
# Cache-Control Response Header lets you do this
# Cache-control is a semi-colon separated list of directives
# HTTP spec defines a lot of directives you can you
	# max-age.  Tells browser how long it can cache response before
	# checking again for the new value of the response
	# Can use max-age to tell browser 'Don't even hit server at all'

# A Little More Info on Max-Age Directive.
# It enables the browser to ask "Has enough time elapsed that I should
# ask the server again for the resource?"

# Pros
	# Browser doesn't even hit the server when the cache is still fresh

# Cons
	# Browser may show out-of-date content
 
											#4 RACK::ETag and RACK::ConditionalGet   
											
# A wonderful pair of Rack middlewares!
# Wikipedia:  Middleware is a computer software that provides services
# to software applications beyond those available from the OS. It can be
# described as "software glue"
# ... from amberbit.com
# "Rack provides a minimal interface between webservers supporting Ruby and Ruby Frameworks" Has become the de facto standard in Ruby web development. Today, ROR, RAMAZE, Sinatra and others use it to talk to Web servers. 

# RACK::ETag
	# gives you built-in automatic ETag generation. 
	# Generates ETag based on MD5 digest of the response body
	# When your Rails app sends back a response body, RACK::ETag looks at it
	# to see if you have already set an ETag on the response. If you didn't,
	# it generates an MD5 digest of the body. This takes very little time.
	# This it put this digest in the ETag in the repsonse header

# RACK::ConditionalGet
	# Higher up on Rack Middleware chain than RACK::ETag.  In other words,
	# it gets called first. 
	# It has a chance to look at response after RACK::ETag
	# generated an ETag from the body. 
	# RACK::ConditinalGet compares the 'If-None-Match' ETag on the incoming 
	# request (which you have already rendered a response for) with the ETag 
	# that was generated in the response. It doesn't know or care if the 
	# response's ETag was generated by RACK::ETag from the body or by your
	# application, all it cares about is comparing them. 
	# If it sees if they are identical but your response has a status code
	# of 200 OK and a body, it will REMOVE the body and change the response's
	# status code to 304 not modified. 

# When both work together, saves network time with zero effort. 
# Does not save server time (renders the response to make and compare
# the digest)
											#5 stale? and fresh_when?
# It would be nice 
	# 1 To generate an ETag  by not having to render the entire view
	# 2 To take advantage of Last-Modified and If-Modified-Since, as these
	# headers are  not generated automatically. 

# In Rails the 
	# stale?
	# fresh_when?
# are how you solve these problems. 

# They are really convenient, concise methods for setting ETag, 
# Last-Modified and Cache-Control Headers

# Can also use them to set directives in the Cache-Control header

# When you use 'stale?' and 'fresh_when?' you pass in a parameter
# which is typically an Active Record instance. 
# To set the ETag on the response, Rails calls 
# ActiveSupport::Cache.expand_cache_key, then makes an MD5
# digest of the result
# Cache key for student looks like students/25-20140630120340"
# That is, name of table, id, and updated-at-timestamp
# You don't have to pass an Active Record object, but can 
# pass any object that responds to cache_key
# Also works for an array of objects 
# By default, Last-Modified is updated_at timestamp by
# default

#1 'stale?

# Verbose example of 'stale?'
def show
	@student = Student.find(params[:id])
		if stale?(last_modified: @student.updated_at,
							etag:					 @student)
			respond_to do | wants |
				#render different formats
			end
		end
end
# If returns true, then respond! 
# If false, as a side effect sets response header to  '304, not modified'

# More concise example of 'stale?'

def show
	@student = Student.find(params[:id])
	respond_with(@student) if stale?(@student)
end


#2 'fresh_when'

# Verbose Example of 'fresh_when'

def show
	@student = Student.find(params[:id])
	fresh_when last_modified: @student.updated_at,
	           etag:					@student
end

# If you are just calling on Rails default rendering of view
# there is no need to know answer to question 'stale?'
# bacause the controller logic same whether answer is true
# or false
# All you care about is the side effect of setting the HTTP
# 304 status code.  The 'fresh-when' method is what you use in
# this case. 
# The differene between 'stale?' and  'fresh_when' is that 
# 'stale?' is asking a question, whereas 'fresh_when' is merely 
# makinga an assersion that the browser content is fresh 
# under the stated conditions. It has the exact same 
# side-effect as 'stale?' If the browser content is fresh, it
# will call 'Head not modified' to set a 304 status code response.
# After that, Rails will only render the view if 'fresh_when' 
# did not set the status code to 304 

#Concise Example of 'fresh_when'

def show
	@student = Student.find(params[:id])
	fresh_when  @student
end

#Its starting to look rediculously easy to set ETags and last_modified headers in Rails
# But there ARE a few gotchas!
# Let's take a look at one of them.
# The form_authenticity_token
# The token has a different value in every browser session
# By default, this token gets inserted into some meta-tags in the HTML head
# But that means that on a single machine if one user logs out and another logs in,
# or even if a single user logs-out and then logs-in with the same username,
# the page content is different because the form authenticity token is different
# What will happen?
# Well, the second user will not be  able to submit any forms if the ETag was marked as
# identical.  
# A work-around that you can use is to include the form authenticity token in the ETag.
# That way if the browser sends the If-none-match header, it will only match if the
# form authenticity token is the same as the last time the browser saw that page. 
# You might want to do something like this:

def new
	@student = Student.new
	fresh_when_last_modified: @student.updated_at,
		e_tag:                    [ @student, form_authenticity_token]
end

def edit
	@student = Student.find(params[:id])
	fresh_when last_modified: @student.updated_at,
		etag:  [ @student, form_authenticity_token]
end

# Some apps display forms from methods other than new and edit, and will
# want to modify those also.

# Using 'stale?' and 'fresh_when' with pagination

# If want to use pagination, and also want to send Etags and last-modified in response headers, it is not at all clear how best to proceed. 

# One approach that works

def index
	@students = Student.order(:name).page(params[:page])

	#Make sure students is indexed by updated_at
	max_updated_at =
		Student.maxumum(:updated_at).
		try(:utc).try(:to_s, number)
	fresh_when etag: "students/all-{count}-{max_updated_at}"
end 

# Another thing to be careful of
# Propagate 'updated_at' to Owning Objects
# The HTML on a page might be dependent on more than just
# the timestamp of the primary resource

class Enrollement < ActiveRecord::Base
	belongs_to :course, touch: true
	belongs_to :student, touch: true
end

#Rails site
#touch
# Saves the record with the updated_at/on attributes
# set to the current time

																		#Warning

#It was argued above that if calling 'stale?' or 'fresh_when'
#you may want to Include the form_authenticity token in ETag.
# It turns out that that is the least of your troubles
# There is all types of content in a form that is independent
# of which resource is being shown, and the last time it was updated. 

#1 Some parts of the response are independent of updated_at
# Some examples include
	# a)  Session Data
			#Flash message
			#Form authenticity token (just mentioned)
			#Current User data
	# b)  Views
	# c)  CSS
#2 Users might see old flash messages 
#3 Users might see some other user's content after logout and login
#4 Users might be unable to submit forms after logout and login
#5 Users might see the right content with stale HTML or CSS

# There is a solution to these problems:
# For session-related problems,use
# Declarative ETags("etagger" Gem)
# Built into Rails 4.0 and above
# Can use with Rails 3.1 with "etagger gem"

Class ApplicationController < ActionController::Base
	etag {flash}
	etag {current_user.try(:id) }
end

class StudentsController < ApplicationController
	def show
		@student = Student.find(params[:id])
		fresh_when @student
	end
end

# Declarative Etags provide a simple mechanism for addng
# one or more values to the string that will be digested
# to generate the ETag. 
# In above example, added flash and current user id

# Want to reset Etags when HTML and CSS Change?
# 1 Brute force: reset all ETags on each deploy
#  # config/application.rb
#  ENV['RAILS_CACHE_ID'] = `git rev-parse --short HEAD`.strip
#  2 Alternatively,
#  set ENV['RAILS_APP_VERSION']
#  3 Last-Modified still doesn't change but it's OK
 
 # Setting Cache-Control Max-age with Rails
 # Do this in Rails using 
 expires_in
 # Tells the browser how long it can render page out of its
 # cache without checking in again
 # Use in 'index' and 'show' actions
 
 class HomeController < ApplicationController
	 def index
		 @courses = Course.order(:id).page(params[:page])
		 expires_in 10.minutes
	 end
	end
# This is extremely efficient. In most apps, a power user
# may override this by holding down shift while refeshing
# the page.

# In order for Browser caching to work, need to make a few changes to configuration

#1  Rack-Mini_Profiler Overrides Cachinng Headers
	# Disables caching and ETags in response header
	# Need to turn it off
	# Here is one way of doing that
	
#	#config/initializers/mini_profiler.rb
Rack::MiniProfiler.config.pre_authorize_cb = ->(env) { false }
# In 'real-life', would put in some logic other than 'false'
# Or, get rid of it out of the Gemfile

#2 Second Change is to NewRelic
# New Relic Changes the body on Each Request
# In order to get the benefit of automatic browser caching from  RACK::ETag
# where you don't have to do any ETags yourself by hand, you need to
# send a consistently identicaly HTML body every time the same user hits
# the same page from the same browser.
# However, New Relic's browser-monitoring middleware injects some content
# into each HTML response.
# This causes RACK::ETag to generate a different ETag every time, since the ETag 
# is based on the digest of the body. 
# So no browser caching benefit. 
# May fix as follows
# Move Browser monitoring injection after ETag:
# config/newrelic.yml
browser_monitoring:
	auto_instrument: false

#config/application.rb
require 'new_relic/rack/browser_monitoring'
config.middleware.delete "Rack::ETag"
config.middleware.use "NewRelic::Rack::BrowserMonitoring"
config.middleware.use "Rack::ETag"

# MAY cause NewRelic's browser statistics to be incorrect. 

# Tip. Hit page twice, and check if second is 200 or 304 
# Do a diff to see what causing to change. 
#
# Demo
# Chrome Browser
# To Clear browser cache.
# In Chrome and Firefox, hitting CTRL SHIFT DEL bring up dialog to
# clear cache
# Another way  is to use Incognito mode. Starts with fresh empty cache
# When you refresh by holding down SHIFT, the browser does not send
# 'If_modified_since' and 'If-none-match' headers
# Free tool to simulate low bandwidth, high network latency and dropped packets. 
# Does not work with localhost.  From Apple Newwork link conditioner. 
# On Linux netem does the same thing and a lot more.  See (put this in your ref manager)
# http://stackoverflow.com/questions/1094760/network-tools-that-simulate-slow-network-connection

#apache bench
b -k -n5 http://skeptics.herokuapp.com/

# One way of seeing is there a difference is tu curl your page
# twice, piping to two different files
# using the -b and -c options (so that each page is being recorded in the same
# session with the same set of cookies. 

#Summary
	#HTTP Headers
		# Last-Modified/If-Modified-Since
		# ETag/If-None-Match
		# Cache_Control : max-age
	# RACK::ETag
		# Make sure no middleware after it that modifies the body
  # 'stale?' and 'fresh_when'
		# are how you set these responses in Rails
	# Progagate updated_at to owning objects with 'touch: true'
	# Dangerous Gotchas in setting own ETags
		# Solution is Declarative ETags
	# Reset ETags on deploy for HTML and CSS changes
	# 'expires_in' method
		# Set the max-age directive on a cache control header

#New Module (Module 5). 
															 # Fragment Caching
# Now your app in on Ruby 2.1, running pretty fast, db interactions are fast,
# you have got browser caching working with ETags and last-modified, but you
# notice that views are rendering a little too slowly. 

# In this module we will cover fragment caching, that allows you to reduce
# server-side rendering time of HTML using memcached or various other 
# server-side cache stores. 
# There are various kinds of cache stores available to you
# mention 4:
	#1 memcached (good-for-production)
		# blazing fast
		# easily distributed
		# supportss time-based expiration of individual cache keys. 
		# has LRU (least recently used) algorithm which is perfect for key-based
		# expiration
		#'d' stands for 'daemon', which means it is a background process
	#2 Redis (good-for-production)
	#3 Filesystem (NOT good-for-production)
		# This is default
		# Can see the contents of your cache.  
		# But don't use in production. 
			# It prevents you from scaling out
			# It does not support time-based expiration
	#4 Filesystem (NOT good-for-production)
	
	# Setting up Memcached in Rails (Production)
		#1 Gemfile
			# add 'dalli' gem
			gem 'dalli'
		#2 config/environments/production.rb
		config.cache_store = :mem_cache_store,
		                     "memcache1", "memcache2"
		#3  Or, if you don't need :race_condition_tti
		config.cache_store = :dalli_store,
		                     "memcache1", "memcache2"
# Notes
# 'memcache1' and 'memcache2' are server names
# You need the 'dalli' gem for both envir conditions
# mem_cache_store is built into Rails
# dalli_store is a substitute that comes with 'dalli' gem.
# Not exactly the same...
# 'dalli_store' has some newer features that allow for improved performance
# but 'mem_cache_store' has one nice feature intentionally left out of 'dalli_store'
# that is the ability to handle what is called the dog-pile effect. (see later)

# If you want to do Local Testing and Development
# then
	#1 config/environments/development.rb
		config.action_controller.perform_caching = true
		config.cache_store = :mem_cache_store
	#2 Install and run memcached
		# This can be easily done with brew install
		brew install memcached
		memcached -vv
		# run with -vv (very-verbose), pluralsight presenter likes to run as

															 # Fragment Caching
# Has been around for a very long time in Rails
# But, some new additions in Rails 4. 
# Fragment caching means caching snippets of HTML 
# Advantage fragment caching has over browser caching is that 
# FRAGMENT CACHING CAN BE SHARED ACROSS USERS
# Example
	<% cache @course do %>
		<%# cache_key: 'courses/1-201406011120000' %>
		<div>
			<strong>Name</strong>
			<%= @course.name %>
		</div>
		<div>
			<strong>Descriptiion</strong>
			<%= @course.description %>
		</div>
	<% end %>

# Cache function takes a key and a block
# It converts the key in basically the same way an ETag is converted
# For this course,the cache key is
# courses/id-updated_at
# Rails also adds the view digest to the end of the cache key
# The cache function tries to read the specified cache key from cache
# If found, that's a cache hit, and it simply gets the HTML content
# out of that cache entry  and renders it, very fast.
# If it is not found, it calls the block to render the view AND
# takes the resulting string and stores it in the cache. 

# Fragment Caching with Arrays as Cache Key
<% cache [@course, @course.teacher] do  %>
	<div>
		<strong>Name:</strong>
		<% @course.name %>
	</div>

	<div>
		<strong>Teacher:</strong>
		<%= render partial:
				"teachers/teacher_link", 
				object: @course.teacher,
				as: :teacher %>
	</div>
<% end %>

# Don't worry about key length, even if you have a long array
# both memcache_store and dalli_store will make and MD5 digest if the
# key is > 250 chars
# But do need to be concerned about the VALUE length
# memcached has a max size of 1MB for the value of a cache entry

# Fragment Caching a Paginated List

	class TeacherController < ApplicationController
		helper_method :teachers_cache_key

		def index
			@teachers = Teacher.order(:id).page(params[:page])
			fresh_when etag: teachers_cache_key
		end

		def teachers_cache_key
			count = Teacher.count
			max_updated_at = Teacher.maximum(:updated_at).
												try(:utc).try(:to_s, :number)
			"teachers/page-#{params[:page] || 1}-#{count}-" + 
				"#{max_updated_at}
		end
end

# Now in views

<% cache teachers_cache_key do %>
	<%= render @teachers %>
<% end %>

# But now that we are using memcached we can do better than before
	def teachers_cache_key
		@teachers_cache_key || =
				"teachers/page-#{params[:page] || 1}-"  + 
				"#{teachers_count}-#{teachers_max_updated_at}"
	end

	def teachers_count
		Rails.cache.fetch('teachers-count') { Teacher.count }
	end

	def teachers_max_updated_at
		Rails.cache.fetch('teachers-max-updated_at) do
			Teacher.maximum(:updated_at).try(:utc).
																	try(:to_s, :number)
		end
	end

	# May also use a Hash as Cache Key
	# In Rails it is combined with current controller and action to
	# generate url

	<% cache page: params[:page], content: "courses-list"  do %>	
						...
	<% end %>


	<%  cache do %>
						...
	<% end %>
	# But is does not include querst string 
	# eg '?page=2'
	
	# Pluralsight presenter does not recommend using a hash
	# too error-prone
	
	# Cache Expiration Strategies
	# cover from best-to-worst
	
	#1 key-based (best)
		# easy to automate
		# fresh data always shown
			<% cache @value do %>	
		# very popular - also an integral part of russian doll caching
    # recommended as default choice
	#2 Time-based (good)
		# Easy to automate, sometimes stale data is shown
			<% cache "key", expires in: 5.minutes,
											race_condition_ttl: 5.seconds do %>
		#Can use when data changes so fast that you cannot benefit
		#from key-based caching
		# Need to be OK with users sometimes seeing data that 
		# is a little bit stale
		# Note that key must NOT include updated_at timestamp
		# Notice that expiration is a feature of memcached,
		# not a feature of Rails
		# provides a solution to the dog-pile effect
		# race-condition-ttl ('time-to-live') 
	#3 Manual (worst)
		 # Call expire_fragment
			<% cache "key", skip_digest: true do  %>

																		 #Demo
#1 gem 'dalli'
#2 go to development.rb
	#Change
		# config.action_controller.perform_caching = true
	#add line
		# config.cache_store = :mem_cache_store
	# also set
		# config.cache_classes = true
#3 Home/controller -index
#refactors code 

#Chrome Browser
#Interesting Setting
#from 'Settings' (Wheel') tab of Development tools
#can ...
# 'Disable Caching (while DevTools is open)'
#  so no client-side caching (useful when testing server side caching)

																		#Summary
#1 Memcached
#2 Dalli gem
#3 Fragment caching
#4 Cache key includes digest of view contents
#5 Cache expiration strategies

#New Module (Module 6). 
														 # Russian Doll Caching
# Nested fragment caching
# DHH coined the term 'Russian Doll Caching' to refer to nested
# cache statements so that even if the outer HTML block can't be
# cached, you can still benefit from cached fragments inside it

#Here we have the students.html.erb partial...
# Whenever it's rendered, it uses the cache if the student hasn't
# changed since the last time
#
#1 Cache each little fragment

	<% cache student do %>	
		<div class = "student">
			<%= link_to student.name, student  %>
		</div>
	<% end %>

# Here we have the show.html.erb for a course
# The entire view is cached based on the updated
# @timestamp for the course. Inside that cached block
# it calls 'render course.students', which iterates over the list
# of students and and for each one calls the partial at the top of
# the slide (the one just above).  The inner fragment has a cache
# statement on the student and the outer fragment has a cache 
# statement on the  course. 
# It there are 20 students on a course, you'll end up with
# 21 entries in the cache: 20 little partials and one big HTML
# block with all 20 of those little ones in it plus the course name.
# One person hits the page, and the entire view is cached. 
# The another hits it and  the whole view is sorte out of 
# the cache. 
# Rails needs to still only make one cache hit because the outer
# view is still cached.
# Now lets say someone new enrolls in the class. The creation
# of an enrollement record causes the courses updated_at to
# be changed. You remember that for ETags we used
# enrollement belongs_to touch: true, and this is also definitely
# necessary for Russian Doll caching. 
# The next time after someone hits the page after this new enrollment
# Rails looks for a cache of the outer HTML fragment and doesnt find it because the updated data has changed, SO IT STARTS rendering but yahoo! it still gets to use the 20 existing tiny HTML fragments inside
# All it has to do is render the course name an one student. 
# It that student's partial has already been rendered by some other 
# view in the system, then it has also been cached, so rendering the outer view is still pretty fast. It saves the new big HTML fragment in
# the cache so that next time it'll be even faster again. 
#Note that if you are paginating, you should include the page number
#in the outer cache key. In this example, showing the whole student list. 
#Now what happens if you change some HTML in the fragment that
#shows the student, but do not change any HTML in the view that described the outer fragment (the course)?
#STOPPED HERE mon night. 
#2 ... and the outer fragment
	<% cache @course do %>
		<div>
			<strong> Name:</strong>
			<%= @course.name %>
		</div>

		<%= render @course.students %>
	<% end %>

#

# Angular Services in Depth.
# Brice Wilson

# There are 5 Different ways to create a service in Angular.

# Services and Providers

# There are 5 functions that may be used to create a service in Angular
# All these fns may be called on the built-in provide service
# All are also exposed on the module object as a convenience

#1 The most fundamental service provider function is 
provider()
# Allows you to explicitly create a configurable provider
# object 
# Three of the remaining 4 functions all internally call
# the provider. Just shortcuts if you don't need all the
funtionality provided by provider.
#2 The first of these is factory(). The first of the
#wrapper funtions. Will probably become your primary 
#service creation function. 
#3 service().  Just a simple wrapper around the factory function
# When you call the service function it will internally call
# the factory function, which will then call the provider function.
#4 The value function is similarly a wrapper around the factory function.
#5 The constant function. This one looks similar but is actually
#fundamentally different. It does NOT call the factory function
# or the provider function. 

# Services are designed to be injected into the other components
# of your application. Their creation is very much part of Angular's
# dependency injection system. 
## Injectable services are known as providers. 
# So before a service is created there must be a provider that
# knows how to create this. 
# The $provide service is used to do that. It is one of the services
# that ships with Angular. It has several components to register
# components with the Angular injector. 
# Once registered, the injector knows how to find the correct instance
# and pass it as a parameter to other components needing them. 

#The basic process of creating a service is that a provide SERVICE
# creates a provider which contains a function that is used to
# create a service. 

# The first function on the $provide service we'll look at is the
# provider() function. 
# This is the most fundamental way to create a service.

$provide.provider('books', function () {
		this.$get = function () {
		var appName = "Book Logger";
		return {
			appName: appName
	};
}

# All other methods, except constant, are wrappers around the provider 
# service

# Using $provide.provider()
# call the 'provider' function on the $provide service
# in above example, the name of service is 'books'
# and the name of the provider will be booksProvider

# The NUMBER ONE RULE for using a provider function is that
# function you provide to it must contain a property named
# $get
# The function assigned to that property is the function that
# will be called by Angular to create your service. 
# The service will then be represented by the return value
# of that function. 
# Creating services withe the provider function is a little more 
# complicated than the other techniques we'll look at. 
# The benefit it offers in exchange for that complexity is the ability
# to configure the underlying provider for your services.  
# None of the other service creation functions allows you to do this. 
# GO TO DEMO. 

# 'Brice' 2.04 of creating services
# "I am using Angular's controllerAs syntax, so I am not injecting
# a scope" !!

# You don't have to inject the provide service into the 
# config function and then call provider directly on the $provide
# service.
# As a convenience, the provider function is also exposed as a function
# directly on the Module object.
#
# angular automatically appends the word 'Provider' to the name
# of the service you specify when creating the underlying provider for
# the service
#
# Factory and Service Functions

#1  Using $provide.factory()
# Simple version of provider when addtional configuration is unnecessary. 
# Registes a service factory function that will return a service instance
# The following is the Angular Source code for the factory function

function factory(name, factoryFn, enforce) {
    return provider(name, {
		    $get : enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
		});
	}

#2 using $provide.service()
# Calls factory function which calls provider function
# Executes constructor function with "new" operator
# Angular source code for $provide.service()

function service(name, constructor) {
    return factory(name, ['$injector', function ($injector) {
		    return $injector.instantiate(constructor);
		}]);
	}

# The service function is just a very thin wrapper around the
# factory function.  The only difference is that the function
# you pass to the service method will be treated as a constructor
# function and called with the javaScript 'new' operator
# It uses the instantiate method of the injector to pass
# to call the function you pass to the service method.
# The instantiate method will then use the new operator
# to execute the function that creates the service. 

# You would use the service method instead of the factory method
# if you specifically needed your function to be treated as
# a constructor and called witht the 'new' operator. 
# There are several reasons why you might want that behaviour.
# One is if you defined an inheritance hierarchy in your code.
# Creating an instance with 'new' will make sure that
# your instantiated object properly inherits from
# its prototype. 
# [Demo] BookLogger App ...

#3 Value and Constant Services
#3a The Value Service
# The 'value' function is just shorthand for calling 
# the factory function with no parameters. 
# If you don't need to inject anything into your factory
# function you can use the value function instead. 

#3b The constant function is not a short-hand version of anything. 
# It simply registers service with injector, no factory/provider calls.
# It allows you to register an object literal function or some other constant
# with the inject, but it doesn't call the service, factory or provider methods
# behind the scenes. 

# A value service can't be injected into a module configuration function but
# a constant service can. 

# Final difference concerns decorators.  Decorators are a way to over-ride
# or modify the bahaviour of an existing service.
# Value services CAN be overridden by AngularJS decorators, but 
# constant services CANNOT. 

# The syntax for both types of service is very similar and straight-forward.
# [Demo BookLogger project] 

# Brice 'Remember services created with the value function are just thin
# wrappers around the factory function. You can use 'value' instead of 
# 'factory' if you don't need to injecct anything into the new service you
# are creating. 
#
# The object that is passed to represent the service in the example just
# has a single property, which is the retriveBadge function below 
#
angular.module('app)
    .value('badgeService, {
		    retrieveBadge: retriveBadge
		});

function retrieveBadge(minutesRead) {
  // my function stuff
	}

# CAN inject constant service into an app.config module, but if you try to
# inject a value service such as badgeService into the app.config module get the following
# error in console

Uncaught Error: [$injector:modulerr] Failed to instantiate module app due to:
Error: [$injector:unpr] Unknown provider: badgeService

# THIS IS IMPORTANT. This is not an error specific to value services. You also cannot inject
# services creates with the factory or service functions.  You can only inject the underlying
# PROVIDER for those services (or a constant service as we saw earlier) 
# Remember that angular creates an underlying provider for services defined with the
# factory and service functions.  THE NAME OF THE PROVIDER is the name of the service
# with the word 'provider' appended to the end.  Injecting in badgeServiceProvider WORKS!! 
# also dataServiceProvider works !

# Dependency Annotations
# Exist for a couple of resons
#1 They inform the injector what services to inject
#2 They suppor minification of javaScript code
# Minification may result in mangled parameter names that causes all code to break

# There are THREE ways to annotate dependencies

#1 Implicitly from function paramater names
#(that's just what we have done so far) - and it is the simplest technique
# But out code would stop working if we tried to minify. 
#2 Use the  $inject property annotation
#You can assign to the inject property of a service an array of the service names
# that should be injected into the service. 
#3 Using the inline array annotation  (Probably the most common)
# To do this, pass an array of strings which are the dependencies as the
# second parameter to your service creation function. The last parameter of the
# array is the function that will create or represent the service. 
# [BookLogger demo] 

# Common Built-in Services

# Promises and the $q service
# the $q service makes it easier to implement asynchronous patterns
# in your angular app. 
#
# The $q service is often referred to as a 'promise library'

# Let's start by defining promises.
# A nice definition by Martin Fowler
# ' In JavaScript, promises are objects that represent the pending result
# of an asynchronous operation'
# See here
http://martinfowler.com/bliki/JavascriptPromise.html
# The $q service is actually more than just a promise library.
# A promise is the pending result of an asynchronous operation.
# The $q service provides an API for working with promises.
# But is also provides an API for so-called deferred objects that
# return promises to the calling code and signal them with results 
# when the asynchronous operation is complete. 

# Asynchronous calls with $q
# There are two parts. 
# We can think of the two parts as a Client and a Service (sic)
# The Client is a component or function that wants to perform
# some work asynchronously.
# The Service is the component that will actually perform the work,
# and notify the client when the work is complete. 
#1 The first thing a client will do is initiate an asynchronous call to the Service
#2 When the Service receives the call it will first use the $q service to 
#  create a new deferred object. The deferred object will act as a conduit through
#  which the service can communicate the status of the asycchronous work back to the client.
#  The deferred object will immediately return a promise back to the client.
#  This will prevent the call to the service from blocking execution while the work 
#  is performed. 
#3 Once the promise is received by the client,  the client can use the promie API to configure 
#  callback functions that execute when the work in the Service is complete. It may also
#  go about its business performing other work. 
#4 Meanwhile, the Service is performing the work the Client requested. 
#5 When the work is complete, the Service uses the deferred API to signal the status
#  of the work (complete, error) to the Client. 
#6 The client executes the appropiate callback function. 
# BookLogger App.  

# $timeout is just a wrapper around the javaScript timeout function
# $timeout takes two arguments.  The first is the function you want to execute;
# the second is the delay in milliseconds. 

#The first two parameters to the then function are 'success'and 'error' callbacks. 
# The first defines the function that should execute if the deferred object in the
# service is resolved successfully with the resolve function
# The second defines the function that should execute if the deferred object is rejected. 
# COULD define as in-line anonymous functions, but Brice thinks that it would be better
# (easier to read) to define as named functions. 

# The deferred object is also capable of another neat trick
# In addition to reporting the success or failure of the work
# being performed, it can also send notifications back to the
# caller WHILE the work is being performed. 
# In order to send messages about the status of the work
# You just call the notify function on the deferred object,
# and pass it the message you want to send to the caller. 

# The 'then' function may take a third parameter.  The
# third parameter is the function that should handle notifications 

# We have seen how to handle the rejection of the promise by specfiying 
# a callback function as the second parameter to the 'then' function
# However, there is actually a better way to handle the rejection of the
# promise as well as other errors that may occur.
# In addition to the 'then' function, promise objects also have a 
# function called 'catch'.  You pass to it a function that will
# handle errors in much the same way as the second parm to the 
# 'then' function handles errors. The 'catch' function is particularly
# useful when you chain it together with the 'then' function.
# The 'then' function also returns a promise, which means you can
# call the 'catch' function on its return value. 
service.returnsPromise()
    .then(successFn)
        .then(allErrorsFn)

# This is a much more robust solution 

# And finally there is the 'finally' function, which can also
# be chained to the 'then' and 'catch' functions.
# It allows you to define a callback that will be executed regardless
# of whether the promise was resolved or rejected. 
# It is a great place to put in cleanup code you want to make sure is
# executed regardless of the result of the promise. 

# Final technique that may be used with promises

# It is possible to wait on an entire array of promises to be resolved 
# before taking some action.
$q.all([booksPromise, readersPromise])
    .then(getAllDataSuccess)
		    .catch(getAllDataError)
# The 'all' function will return a promise when 
# all of the promises in the array have been 
# resolved or rejected. 
# We can then process that promise by calling 'then' and 'catch'
# etc. just like any other promise. 
# The one additional wrinkle is that the data passed
# to the success handler (named dataArray in code eg)
# is actually an array of the data returned from 
# the promises in the array. 
# The data will be returned in the same index position
# as the promise it goes with in the array passed to the
# all function. 
#
# Routing Overview
# Important.  Angular Source Code for Routes Service

var ngRouteModule = angular.module('ngRoute', ['ng'])
                            .provider('$route, $RouteProvider)

# Remember that only services that are created with the provider function
# are configurable in the module's config function.
# The routes service IS configured with the provider function, using code we
# might write ourselves to create a configurable service.  
# Note that the service being created is named '$route', which means that angular
# will create an underlying provider by appending the word 'provider' to the
# end of the service name. 
# Therefore, we will be injecting $RouteProvider into our modules config function
# in order to configure our routes. 

# $routeParams is a service that allows you to retrive values passed as params
# in the url. 

# otherwise function (routes)
# Brice 'It is worth noting that in Angular prior to version 1.3, you had to pass
# a route config object to 'otherwise' function. You still can, but if the route you
# want to redirect to already has an entry in a 'when' routes function, you can just
# pass the string that represents the route. 

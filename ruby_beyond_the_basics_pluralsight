#Ruby Beyond the Basicss
#John Cinnamond
#Mats "Ruby is Simple in Appearance, but if very complex inside"

	2.times do
	puts "hello".upcase
	end

#but why cannot you write this?

	do 2 times
	  puts.upcase "hello2
	end
#In Rails you can write this!
	class Person < ActiveRecord::Base
	    has_many :addresses
	end

# Three big ideas shape ruby  (How Ruby Works)

	1.  Object Orientation
	2.  Functional Programming
	3.  Metaprogramming

#Each of these ideas gets its own module.

#Ruby has its own inbuilt REPL (Read, Evaluate, Print, Loop) called IRB

gem install pry

# Ruby is OO language, but what does this mean?
# OO languages
# JavaScript, C++, C#, Ruby, Python, Java, Smalltalk, Objective-C

# Alan Kay, the person who invented the term 'objjected orienated' had this to say about c++

    # I can tell you that C++ wasn't what I had in mind"
    # (OOPSLA, 1997) 

# Is Ruby what Alan Kay had in mind? 
# Well maybe. Ruby was inspired by Smalltalk, a language written by Alan Kay 
# In Ruby objects are defined by two things:
    #1  Local state
        #   What is local state?
        #   Imagine we have two people each represented by different objects
        #   Each person has a name. Mary and Bob, say. 
        #   Mary does not share the name with anyone else
        #   If we change the name of Bob to David, then Mary IS COMPLETLY UNAFFECTED
        #   True even if both objects called 'Mary' (changing the name of one will
        #   leave the other completely unaffected)
    #2  Objects can send messages to one another
        # Messages, of course, are method calls
        # One object can send a message to another object, it is then up to that other
        # object what to do about it.
        # 'Change your name Mary'
        # Mary: OK
        #       No! You can't tell me what to do. (Raise an exception)
        #       Look back blankly  (No method error) 
        # An object can only send messages. It cannot control what happens when message is received.
        # Think of objects are autonomous.

# In Ruby, almost everything is an object.
ruby> a = 10
# 'a' is an object

ruby> c=%i(a b c)   # => [:a, :b, :c]
# The array is an object
# each symbol is an object
=> [:a, :b, :c]

class User; end
john = User.new
# John, of course, is an object
# But class is also an object
ruby >User.class
=> Class

r = (1..10)e


ruby >code = Proc.new {"I am not an object, I am a free man"}
=> #<Proc:0x00000004fa7248@(pry):6>
ruby >code.class
=> Proc

# An 0bject in Ruby was defined above as something with local state that responds to messages
# But if everything is an object, this has some implications for locat state
# local state must be a colloction of objects.
# After all, everything (almost) is an object, so there is nothing else local state can be. 
# We can now give a complete definition for an object in Ruby. 
    # An object is a collection of references to other objects (local state) that responds to certain
    # messages
# The messages an object responds to are controlled by defining methods in the object's class.
# But wait! everthing is an object. Are methods objects? Yes. 
# We do not normally deal with methods as objects, but it is possible to do so. There is a special
# method in every object called method 
ruby >str ="str object"
=> "str object"
ruby >m=str.method(:upcase)
=> #<Method: String#upcase>

# The method is an object. It has an associated class and it has local state, and you can send messages
# to it.
# The most interesting message is probably call
ruby >m.call()
=> "STR OBJECT"
# This idea of everything being an object has some implications for how we write Ruby code.
# WE SHOULD ALWAYS TRY TO DO IT BY SENDING MESSAGES TO OBJECTS. 
# A very good example of this is looping over values in an array
# In a less OO-orientated language you might have to use a control structure to do this,
# such as a 'for' loop. 
# In Ruby, typically send method called 'each' to our array, 
# togeher with a block of code to be exected for each value



ruby >arr.each do |i| 
     |  puts "hello" * i
     |end  
hello
hellohello
hellohellohello
hellohellohellohello
=> [1, 2, 3, 4]

#The definition of an object in Ruby as something with
#local state that can respond to messages can lead to probems
# where local state is a collection of referneces to other
# objects. 

# Imagine we have user class with two attributes: name and age
# The name is a STRING OBJECT.
# The age is a fixnum object
# But what about the local state for string and fixnum?
# Let's consi0der fixnum. lets say user age is  37.
# It has  a value of 37, but this cannot be a reference to
# another object. 

    #1 String
    #2 Float
    #3 Fixnum
    #4 Array
    #5 Rational
    #6 Hash
    #6 True
    #7 False
    #8 Symbol 

# These may be considered primitive data types. That is they
# cannot be represented by another object.  
# But Ruby does not want to break the the idea of everything being
# an object. Indeed, when you create a value like 37 it has 
# methods you can call on it, and it has a class called fixnum
# (methods include odd? even? zero?) 
# So are these things really objects. Well ..., yes. You
# can treat them as if they were objects, but they are special
# kinds of objects. 
# They are special in two ways:
    #1 They hold special internal state that is NOT a ref to another object
    #2 The also have special constructors 
    #  We normally create an object by calling the 'new' methd
    #  on the obects clase
        object = class.new()
    # but for these special objects, we normally create them directly.
    # For example, to create a new fixnum, we just write:
        num = 42
    # The ruby interpreter recognises this and creates a new fixnum
    # object for us. The same applies to strings and so on. 
    # This makes sense. If call fixnum.new() what arg will you pass in
    # Only thing that makes sense is the number itself, but this
    # leads to an infinite regress. No use. 
# But can forget about special nature and treat these objects as
# normal objects. 
    # Can assign them to variables
        a = [1,2,]
        b = " - "
    # Can call methods on them
        a.size
    # Pass them as parameters to other methods
        a.join(b)
# Can also treat classes as normal classes
# Can for example define new method on string classs that
# counts the number of vowels.

class String
    def number_of_vowels
        gsub(/[^aeiou]/, '').size
    end  
end  
=> :number_of_vowels
ruby >"hello".number_of_vowels
=> 2

#just because you can add methods to built-in classes like string
# does not necessarily mean you have to. 
# Rails, however, does this quite a lot. 
ruby >require 'active_support'
=> true
ruby >require 'active_support/core_ext/numeric'
=> true
ruby >4.minutes.ago
=> 2015-11-19 02:08:48 +0000
# 'Minutes' is just a new method defined on the fixnum class.
# The special constructors for these special classes are just that -
# constructors.   And they are just creating objects
# The local state for these objects is special, unnecessarily so,
# but most of the time you do not need to worry about the details. 


# Classes
# To create a class, use keyword 'class' followed by name of 
# class. The name can be pretty much anything you want, but must
# start with capital letter.
# Now add some methods to class. Do this by writing ;'def'
# followed by method name, followed by method body, finally
# closed by keyword 'end'. Method name anything you want. But must
# start with lc.
# close clase by typing 'end'
ruby >class User
     |  def can_vote?
     |    @age >=18
     |  end  
     |end  
=> :can_vote?
ruby >require 'date'
=> false
ruby >require 'date'
=> false
# There is a special method called 'initialize that gets run
# by default when you create a new instance of this class
# We can add an intialiaze method to our class to store the users
# age in an instance variable. 
# Variable names that begin with '@' designate instance variables.
# IN RUBY THE LOCAL STATE OF AN OBJECT IS THE SET OF ITS
# INSTANCE VARIABLES. 
ruby >class User
     |  def initialize(date_of_birth)
     |    days_since_birth = Date.today - Date.parse(date_of_birth)
     |    @age = days_since_birth / 365
     |  end  
     |end  
=> :initialize
# Variable such as 'days_since_birth' are scoped to the method'
# Only instance varibles may be accessed from other methods. 
# Ruby is a dynamic language and as such the definition of a class
# is never finalized. 
# To add the intialize methood to a class that already existed,
# we simply reopened it. 
#
# To create an object of this class, we call the 'new' method on it.
# ANY ARGUMENTS YOU PASS TO NEW WILL BE PASSED ON TO THE OBJECTS
# INITIALIZE METHOD. 
# The object created will then respond to any methods you have defined.
#
ruby >john = User.new("2000-01-01")
=> #<User:0x000000040a10c8 @age=(5801/365)>
ruby >john.can_vote?
=> false

# In Ruby, the local state of an object is the sum of its instance
# variables 

# Very easy to create a class. But this is Ruby, so there is usually
# more to the story. Classes are objects too.  This means they also
# have methods. You can create class methods alongside object methods
# in the class defintion. The only difference is that class methods
# are prefixed by 'self.'
# Class methods are typically used to create objects.
# There is already a class method that we have been using
# called 'new' that exists by default on all classes. 

ruby >class User
     |  def self.new_voter
     |    date_of_birth = Date.today - (18 * 365)
     |    new(date_of_birth.to_s)
     |  end  
     |end  
=> :new_voter
# call class method on User class
ruby >voter = User.new_voter
=> #<User:0x00000004110bd0 @age=(18/1)>
ruby >voter.can_vote?
=> true

# Methods
# Methods add behaviour to a class

ruby >def yet_another_method(first_arg, second_arg)
     |  "you have passed in #{first_arg}, #{second_arg} "
     |end  
=> :yet_another_method

# name is lc with underscores

ruby >class User
     |  def initialize(name)
     |    @name = name
     |  end  
     |  def name
     |    @name
     |  end  
     |  def name=(name)
     |    @name = name
     |  end  
     |end  
=> :name=
ruby >obj = User.new("Bob"
     |)  
=> #<User:0x00000003865b20 @name="Bob">
ruby >obj.name="Mary"
=> "Mary"
ruby >obj.name
=> "Mary"

#1 Methods that return an attribute value are usually 
#  named after the attribute
#  For example if you have a method called 'name' the
#  method to access this should also be called 'name'
#  and not, for example, 'getname'
#  Methods that SET an attribute are named after the attribute
#  followed by an equals sign. So the method to set 'name' 
#  should be called 'name='
#  This allows some special ruby synntax that lets us write
       obj.name="Mary"
#   Ruby spots the special assignment syntax and calls the
#  'name=' method.

#2 Methods that return true or false usually end with a question mark
ruby >class Person
     |  def initialize(age)
     |    @age = age
     |  end  
     |  
     |  def can_vote?
     |    @age > 18
     |  end  
     |end  

#3 Methods can end with an exclamation mark if they do something
#  unexpected or destructive.
#
ruby >class Person
     |  def reset!
     |    @age = nil
     |    ene
     |  end     
     |end  
=> :reset!
# The exclamation mark here should mean 'look out!'
# It is good practice to have a method without the exclamation
# mark that does something safer. 
ruby >a =[1,2,3,4,5]
=> [1, 2, 3, 4, 5]
ruby >a.select(&:even?)
=> [2, 4]
ruby >a
=> [1, 2, 3, 4, 5]
ruby >a.select!(&:even?)
=> [2, 4]
ruby >a
=> [2, 4]
# Adding an exclamation mark to select modifies the original array
# It is also quite common in Rails for the exclamation mark
# at the end of a method to indicate that the method raises an
# excetion.
user = User.new
user.save
user.save!
#Both do the same thing if successful
#but if for some reason save fails, then '.save' return false
# whereas '.save!' returns an exception.
# This practice is less widely adopted outside Rails community.

#3 after method name comes parameter list
# arg names are separated by commas
# parm list is optional
# Optional Parameters

ruby >def greet(name, informal=false)
     |  if informal
     |    "hi #{name}"
     |  else  
     |    "hello #{name}"
     |  end  
     |end  
=> :greet
ruby >greet 'tom'
=> "hello tom"
ruby >greet('tom', informal=true)
=> "hi tom"
ruby >greet('tom', informal=true)
=> "hi tom"
ruby >greet 'tom', true
=> "hi tom"
# Can have multiple optional parameters. 
# The only rule is that they must be the first or last parameters
    def optional_first(first=1,second=2, third)
    def optional_last(first, second=2, third=3)
# Cannot, for example, have first and last parmeters optional and
# have required second parameter
    de no_holes_allowed(first=1, second, third=3)
# Probably good practice for to have just one optional parameter
# and for that to be the final one. 
# Starting in Ruby 2, it is possible to use named parameters.
# In Ruby 2.0, this allowed you to add named defaults
# Ruby 2.1 extended this to named-required-arguments

ruby >def greeet (name, informal=false, shout=false)
     |  greeting = if informal then "hi" else "hello" end
     |  message = "#{greeting} #{name}"
     |  if shout
     |    message.upcase
     |  else  
     |    message
     |  end  
     |end  
=> :greeet
ruby >greeet("thomas", false, true)
=> "HELLO THOMAS"
# Forced to provide second argument.
# Also, not immediately obvious what arguments mean
# Rewrite using named parameters. 

ruby >def greet (name,informal: false, shout: false)
     |  greeting = if informal then "hi" else "hello" end
     |  message ="#{greeting} #{name}"
     |  if shout 
     |    message.upcase
     |  else  
     |    message
     |  end  
     |end  
=> :greet
ruby >greet("thomas", shout:true)
=> "HELLO THOMAS"
ruby >greet("thomas", informal: true, shout: true)
=> "HI THOMAS"
# You might notice that this looks a lot like hash syntax. 
# And you would be right! This was introduced into Ruby
# because a lot people were using hashes to pass options into methods.
# Using named parameters works much the same way BUT THE ARGUMENTS
# ARE CHECKED, which stops you using arguments that are not supported. 
# THEY CAN ALSO BE GIVEN DEFAULT VALUES IN THE PARAMETER LIST
# Ruby 2.1 added support for named parameters without a default
# Thi means you can write the parameter name followed by a colon
# but then not provide any default value. 

ruby >def greet(name:)
     |  "hello #{name}"
     |end  
=> :greet
ruby >greet(name: "John")
=> "hello John"

# This can be great for providing extra documentation for what the
# arguments do
merge(from: list1, into: list2)

# Every method in Ruby returns a value
ruby >class MyClass
     |  def odd_or_even(num)
     |    if num.odd?
     |      "odd"
     |    else  
     |      "even"
     |    end  
     |  end  
     |end  
=> :odd_or_even
ruby >MyClass.new.odd_or_even(3)
=> "odd"
#  Duck Typing
# Let's talk about Ruby's dynamic nature
# We have already seen how we can reopen classes to define new methodss
# We can also redefine methods
# There is no guarentee you can look at Ruby code and be certain
# about how it will behave at runtime
# This difficulty has lead to a shift in the way Ruby developers
# think about type safety.  
# Instead of checking what type of object has been passed to a method,
# which gives us no guarentee about the messages it will accept, it
# is more common to use something called Duck Typing. 
# "If it walks like a duck and quacks like a duck, it probably is 
# a duck 
# What this means is that instead  of checking the class of an object,
# we ask questions about its behaviour. That is WE ASk WHAT MESSAGES
# IT WILL RESPOND TO. 
# An example of Duck typing
ruby >def print_info(obj)
     |  if obj.class == User
     |    obj.name
     |  else  
     |    obj.to_s
     |  end  
     |end  
=> :print_info
# The above code could fail
# So use Duck typing to replace the class check with
# checking the object's behavior.
# This works by using the method 'respond_to'

ruby >def print_info(obj)
     |  if obj.resond_to?(:name)
     |    obj.name
     |  else  
     |    obj.to_s
     |  end  
     |end  
=> :print_info
# Writing the code in this way also brings some other advantages
# For examole could use this method by passing in an object that
# isn't a user but that does respond to name
# Perhans its an admin user. Our code does not care.
# It is not concerned about what the object IS, only about how
# the object behaves. 
# Good Ruby code should not be concerned with Classes but instead
# concentrate on the messages passed between objects.
# It should be easy to change the object being used as long as it 
# responds to the same messages. 

# Attributes.  
# Instance variables in Ruby are much more straightforward
# The usual way to create a method in Ruby is to define it
# as part of a class. 
# For  an instance variable, however, the usual method is just
# to use it.  There is no need to declare in advance or specify
# its type. We treat instance variables like normal variables except
# that their name has to start with a single '@' symbol 
# EVERY INSTANCE VARIABLE IS GUARENTEED TO CREATE  A VALUE
# If you have not assigned a value, it will return a value 'nil' 
# when used. 

ruby >class BuggyUser
     |  def initialize(name)
     |    @name = name
     |  end  
     |  
     |  def say_my_name
     |    puts "My name is #{@naem}" # Oh no! a typo!
     |  end  
     |end  
=> :say_my_name
ruby >me = BuggyUser.new("thomas")
=> #<BuggyUser:0x00000003aca438 @name="thomas">
ruby >me.say_my_name
My name is 
=> nil
#   In addition, you cannot access an instance variable from outside
#  an object
# The only interaction with objects that Ruby supports is sending
# messages to them, and getting objects back in response.
# So if you want to get the value of another object's instance
# variable, you have to send it a message. 
# Adding support for these messages is pretty trivial.
# If you want to return the value of an instance variable
# we simply add a reader method. 

ruby >class User
     |  def name
     |    @name
     |  end  
     |end  
=> :name

# All thsi method does is return the instance variable
# More accurately, it is returning a reference to the object
# that the instance variable points to

# If we want an external object to set the value of an instance
# variable, then we use a writer method. 
# THIS IS A METHOD NAME ENDING IN EQUALS
# and it takes a single argument of the new value of the
# instance variable. 

ruby >class User
     |  def name=(name)
     |    @name = name
     |  end  
     |end  
=> :name=

# This allows a special synthatic form.
ruby >user=User.new
=> #<User:0x00000003c8fd40>
ruby >user.name="thomas"
=> "thomas"
ruby >user.name
=> "thomas"
 
# Running these methods might get a little tedious, so Ruby
# adds some keywords to create them for you.  
# In your class definition you can create a reader
# method by typing 'attr_reader followed by a symbol
# with the name of your instance variable
    attr_reader :name 
# Adding writer methods is just as easy. 
   attr_writer :name
# To add both reader and writer method,
   attr_accessor :name

ruby >class User
     |  attr_reader :name, :age
     |  attr_writer :name
     |end  
=> nil
ruby >class User
     |  attr_accessor :name
     |end  
=> nil
ruby >User.public_instance_methods(false).grep(/name/)
=> [:name, :name=]
ruby >User.public_instance_methods(false)
=> [:name, :name=, :age]

# Reuse
# Ruby provides two ways of sharing behaviour bettween different classes
#1 Inheritance
#2 Modules

    #1 Inheritance
# Ruby supports single inheritance
# Every class in ruby has exactly one superclass
# Specify a superclass by typing 'less than (<)' followed
# by the name of the superclass

ruby >class User
     |  attr_reader  :name
     |  
     |  def initialize(name)
     |    @name = name
     |  end  
     |end  
=> :initialize

ruby >class AdminUser < User
     |  def is_admin?
     |    true
     |  end  
     |end  
=> :is_admin?

ruby >user = AdminUser.new("Tom")
=> #<AdminUser:0x000000051e3160 @name="Tom">
ruby >user.name
=> "Tom"
ruby >user.is_admin?
=> true

# A class inherits all of the methods from its superclass unless
# it explicitly overrides or removes them
# If you do not explicitly set the superclass, then Ruby assumes
# that it is 'Object'
# The superclass of 'object' is BasicObject

ruby >AdminUser.superclass
=> User
ruby >User.superclass
=> Object
ruby >Object.superclass
=> BasicObject
ruby >BasicObject.superclass
=> nil
# We can always reopen classes
# For example, if we reopen the Object class and add a method
# this becomes available for all objects 

ruby >class EmptyClass
     |end  
=> nil
ruby >obj = EmptyClass.new
=> #<EmptyClass:0x000000052945f0>
ruby >obj.ping
NoMethodError: undefined method `ping' for #<EmptyClass:0x000000052945f0>
from (pry):24:in `__pry__'
ruby >class Object
     |  def ping
     |    "pong"
     |  end  
     |end  
=> :ping
ruby >obj.ping
=> "pong"
# Can call this method on new objects as well

ruby >new_object = EmptyClass.new
=> #<EmptyClass:0x00000005320668>
ruby >new_object.ping
=> "pong"
ruby >"Hello".ping
=> "pong"
ruby >7.ping
=> "pong"
ruby >[1,2,3].ping
=> "pong"
# If you want to see where a method came from
# we can use the Method class to investigate it

ruby >m=obj.method(:ping)
=> #<Method: EmptyClass(Object)#ping>
ruby >m.receiver
=> #<EmptyClass:0x00000003fdf4f0>
ruby >m.owner
=> Object

#receiver is called on instance of Empty Object, where we got method

# Modules
# A module in Ruby is really just a collection of methods
#1 Defined in much the same way we define classes


ruby >require 'date'
=> false

ruby >module Employee
     |  attr_accessor :start_date
     |  
     |  def employment_length
     |    days = Date.today - start_date.to_date
     |    "#{days.to_i} days"
     |  end  
     |end  
=> :employment_length

ruby >class User
     |  include Employee
     |end  
=> User
ruby >u = User.new
=> #<User:0x0000000420e140>
ruby >u.start_date = Date.today - 365
=> #<Date: 2014-11-29 ((2456991j,0s,0n),+0s,2299161j)>
ruby >u.employment_length
=> "365 days"

#2 We can even use helpers like attr_accessors
#3 Modules: a collectin of methods
#4 We can add a module to a class by using the keyword 'include'
# followed by the module name.
# This makes all the methoods in the vomdule availablt to the class.
# It is though you typed out the methods of the module at this point
#5 When we instantiate the class, we have access to all the methods
# in the module

# If you think a module looks a bit like a class, then you would be
# right!
# **** The SuperClass of Class is actually "Module'
# So Classes are just special types of modules, oness that we
# can instantiate by calling 'new'
# However, although a class can only have one supercalls, you can 
# include as many modules as you want. 
# We have just sctatched the surface with Modules. The world is just
# about to get more complex, and more interesting.

# Extend
# There is anoher way to use modules, and this new way is more interesting
# We have already used the 'include' keyword to add the methods in a module
# to a class
# But we can also use the 'extend' keyword to add the methods to a
# single instance of a class

ruby >require 'date'
=> false

ruby >module Employee 
     |  attr_accessor :start_date
     |end  
=> nil

ruby >class User
     |end  
=> nil

ruby >user = User.new
=> #<User:0x00000004020bf8>
ruby >user.extend(Employee)
=> #<User:0x00000004020bf8>
ruby >user.start_date = Date.today
=> #<Date: 2015-11-29 ((2457356j,0s,0n),+0s,2299161j)>

# Our new object now has the methods from the module!
# ** But where did these methods go? ***
# The most obvious place would be into the object's class
User.public_instance_methods.grep(/start_date/)
=> []
# No!

ruby >user.methods.grep(/start_date/)
=> [:start_date, :start_date=]
ruby >another_user.methods.grep(/start_date/)
=> []
# methods not available to another instance of the class!!
# Sp where do the methods go?
# When we use 'extend' we suddenly have methods that are not defined in
# the class
# It LOOOKS LIKE we have methods defined in the Class and Object!!
# Ruby does not do this!
# Instead does something that is simultaneously wonderful and confusing
# *** It adds a special class to each object to hold
# methods that get added to just that obejct and not that
# object's class
# Every Object has its own class, and every class has a superclass
# ** But very object also has its own class, called a Singleton Class
# that allows an individual object to be extended without affecting the 
# other instances of that class.
# Each objject has its own singleton class with its own methods
#  SEE DIAGRAM 
# Every object in Ruby has its own singleton class
# In more recent versions of Ruby, can access Singleton class by
# calling a method on an object
# So here are the missing start_date methods!! 

ruby >user.singleton_class.public_instance_methods.grep(/start_date/)
=> [:start_date, :start_date=]

# When ee extend an object it is like we include an object in the modules
# singleton class

# Method Dispatch
# Just a fancy way of saying "When I call a method How does Ruby work out
# where that method was defined?"

obj.do_something

#1 When we call a method on an object, Ruby first checks in the Singleton Class
# for the method definitin
#2 Then it looks in the object's Class

# *** To keep things consistent, the object's class is the superclass of the
# object's singleton class ***

#3 It the method is not found in object's class, then looks in ITS superclass

#4 It keeps going up the inheritance chain until it reaches basic object

#5 The superclass for Basic Object, and only for Basic Object, the superclass is nil

#6 So now Ruby knows that the object has no matching method, ie it doess
# not respond to the message?  WELL KINDA!!  This is not the full story

#7 If Ruby gets all the way to Basic Object and the method is still not  defined,
#  then is goes all the way back down to the singleton class and starts again.
#  but this time it looks for a method called 'method_missing'
obj.method_missing
# ** If method_missing is found in the singleton class, then thig gets called**
# If not proceeds again up the Class inheritance chain, all the way up to 
# Basic Object. At which point, if it cannot find 'method missing', it has
# no place to go. It finally gives up and raises a '#NoMethodError'
# method missing takes three arguments
method_missing(name, *args, &block) 
#1 name
#2 a list of params from original method call
#3 an optional block

#2 We splat the arguments for param list
# When we write an asterisk before the paramater name
# it really just means 'take all the arguments left over
# at this point and turn them into a single array. 
some_method(a,b,c) -> some_method([a,b,c])
# In Ruby, we call that a splat

ruby >class AnyP
     |  def method_missing(name, *args)
     |    if name.to_s.start_with?('p')
     |      "You called #{name} with #{args.inspect}"
     |    else  
     |      super
     |    end  
     |  end  
     |end  
=> :method_missing

ruby >has_p = AnyP.new
=> #<AnyP:0x000000041ce900>
ruby >has_p.catcus
NoMethodError: undefined method `catcus' for #<AnyP:0x000000041ce900>
from (pry):25:in `method_missing'

ruby >has_p.xylophone
NoMethodError: undefined method `xylophone' for #<AnyP:0x000000041ce900>
from (pry):25:in `method_missing'

ruby >has_p.thomas
NoMethodError: undefined method `thomas' for #<AnyP:0x000000041ce900>
from (pry):25:in `method_missing'

ruby >has_p.pancake
=> "You called pancake with []"

ruby >has_p.pancake(true, 17, :whatever)
=> "You called pancake with [true, 17, :whatever]"

#1 The method name is symbol.  Need to turn it into string
#2 'super' just means call exactly the same method with exactly the
#  same arguments as is defined in my superclass

# Constants

#Constants in Ruby much the same as in other languages
# They look a bit like variables, but they start with a capital letter
# Conventional to use UC words for constants
PI = 3.14
# Ruby ALLOWS you to change constants. Issues a warning but assumes you
# know what you are doing. 
#2 Constants are scoped to the surrounding module

ruby >module Geometry
     |  PI = 3.14
     |end  
=> 3.14

ruby >module Circle
     |  PI = 3.142
     |end  
=> 3.142

ruby >Geometry::PI == Circle::PI
=> false

# Class names also have to start with a capital letter
# This is NOT a coincidence
# *** Classes are constants! ***
# When you define a new class, then is just creates a new constant using
# the Class name and assigns it to the Class you just defined. 
# By default, Classes are created as constants under the object class

# Ruby provides some handy methods for looking at constants

ruby >Object.constants
=> [:Object,
 :Module,
 :Class,
 :BasicObject,
 :Kernel,
 :NilClass,
 :NIL,
 :Data,
 :TrueClass,
 :TRUE,
 :FalseClass,
 :FALSE,
 :Encoding,
 :Comparable,
 :Enumerable,
 :String,
 :Symbol,
 :Exception,
 :SystemExit,
 :SignalException,
 :Interrupt,
 :StandardError,
 :TypeError,
 :ArgumentError,
 :IndexError,
 :KeyError,
 :RangeError,
 :ScriptError,
 :SyntaxError,
 :LoadError,
 :NotImplementedError,
 :NameError,
 :NoMethodError,
 :RuntimeError,
 :SecurityError,
 :NoMemoryError,
 :EncodingError,
 :SystemCallError,
 :Errno,
 :ZeroDivisionError,
 :FloatDomainError,
 :Numeric,
 :Integer,
 :Fixnum,
 :Float,
 :Bignum,
 :Array,
 :Hash,
 :ENV,
 :Struct,
 :RegexpError,
 :Regexp,
 :MatchData,
 :Marshal,
 :Range,
 :IOError,
 :EOFError,
 :IO,
 :STDIN,
 :STDOUT,
 :STDERR,
 :ARGF,
 :FileTest,
 :File,
 :Dir,
 :Time,
 :Random,
 :Signal,
 :Process,
 :Proc,
 :LocalJumpError,
 :SystemStackError,
 :Method,
 :UnboundMethod,
 :Binding,
 :Math,
 :GC,
 :ObjectSpace,
 :Enumerator,
 :StopIteration,
 :RubyVM,
 :Thread,
 :TOPLEVEL_BINDING,
 :ThreadGroup,
 :Mutex,
 :ThreadError,
 :Fiber,
 :FiberError,
 :Rational,
 :Complex,
 :RUBY_VERSION,
 :RUBY_RELEASE_DATE,
 :RUBY_PLATFORM,
 :RUBY_PATCHLEVEL,
 :RUBY_REVISION,
 :RUBY_DESCRIPTION,
 :RUBY_COPYRIGHT,
 :RUBY_ENGINE,
 :TracePoint,
 :ARGV,
 :Gem,
 :RbConfig,
 :Config,
 :CROSS_COMPILING,
 :ConditionVariable,
 :Queue,
 :SizedQueue,
 :MonitorMixin,
 :Monitor,
 :Noexec,
 :FileUtils,
 :Etc,
 :Pathname,
 :Bundler,
 :Delegator,
 :SimpleDelegator,
 :Tempfile,
 :OptionParser,
 :Digest,
 :URI,
 :StringScanner,
 :ScanError,
 :BasicSocket,
 :Socket,
 :SocketError,
 :IPSocket,
 :TCPSocket,
 :TCPServer,
 :UDPSocket,
 :UNIXSocket,
 :UNIXServer,
 :Addrinfo,
 :Timeout,
 :TimeoutError,
 :Net,
 :Zlib,
 :StringIO,
 :Date,
 :DateTime,
 :CGI,
 :Fcntl,
 :OpenSSL,
 :SecureRandom,
 :Resolv,
 :Set,
 :SortedSet,
 :TSort,
 :Forwardable,
 :SingleForwardable,
 :PrettyPrint,
 :PP,
 :Pry,
 :MethodSource,
 :Shellwords,
 :CodeRay,
 :Slop,
 :PryDoc,
 :YARD,
 :RUBY18,
 :RUBY19,
 :SymbolHash,
 :Insertion,
 :OpenStruct,
 :Logger,
 :Readline,
 :Employee,
 :User,
 :AnyP,
 :Geometry,
 :Circle,
 :RUBYGEMS_ACTIVATION_MONITOR]

# Now create a new class 
ruby >class ExampleClass
     |end  
=> nil
ruby >Object.constants.grep(/ExampleClass/)
=> [:ExampleClass]

# We can use this constant in the same way we have been using our class
# or example, by calling 'new' on it. 

ruby >Object::ExampleClass.new
=> #<ExampleClass:0x0000000402ced0>

# This is because the new constant IS out new class

# We can do more with constants than simply listing them
# We could, for example, delete them

# There is a method called 'remove_const' 

ruby >Object.remove_const(:ExampleClass)
NoMethodError: private method `remove_const' called for Object:Class
from (pry):50:in `__pry__'

# We cannnot call remove_const on Object as it is a private method
# However, Ruby is a very permissive language
# Saying a method is private is merely just advisory

#We can work around the above restriction by using a special method called 'send'

ruby >Object.send(:remove_const, :ExampleClass)
=> ExampleClass

# now
ruby >ExampleClass.new
NameError: uninitialized constant ExampleClass
from (pry):53:in `__pry__'


# This gives us a convenient way of undefining Classes
# This might not seem to be particularly useful
# But is forms part of how Dynamic Reloading works in Rails
# Rails keeps track of the classes you load
# So that if it wants to reload everything, all it has to do is
# use a remove_const to throw away the classes and then load everything again

# We an also use the const_set method to define new classes
# The special keyword class that we have been using is 
# *** actually unnecessary***

ruby >Object.const_set(:NewClass, Class.new do
     |    def ping
     |      "pingpong"
     |    end  
     |end)    
=> NewClass
ruby >NewClass.new.ping
=> "pingpong"

# Ruby's OO nature follows a small set of rules.
# and follows them consistently
# Objects really ARE at the heart of Ruby

# Most of Ruby  sticks to the behaviour outlined in this module
# There is one exception
# First-class functions!

# Functions
# As well as OO, Ruby influenced by functional programming
# Ruby selective in what it takes from functional programming

# What if functional programming?
# Essentially a type of programming that
# uses the mathematical notion of functions to perform
# calculations.

# ** In mathematics a function is defined as the relation
# between a set of input values and a set of output values
double(x) = x*2
          
# maximun of two numbers
# Mathematics: a definition of the relationship 
# between input and output values

           | x  if x > y
max(x.y) = | 
           | y  otherwise

# Ruby - the set of steps necesssary to produce correct value

ruby >def max (x,y)
     |  if x > y
     |    x
     |  else  
     |    y
     |  end  
     |end  
=> :max

ruby >max(100,2)
=> 100
ruby >max(2,100)
=> 100

# First even example
#
                   | nil                     if empty?(list)
first_even(list) = | head(list)              if even?(head(list))
                   | first_even(tail(list))  otherwise

# Some very procedural Ruby code

ruby >def first_even(list)
     |  for i in list
     |    if i.even?
     |      break i
     |    end  
     |  end  
     |end  

=> :first_even
ruby >first_even([1,3,5,7,66,4])

# The mathematical funcion is recursive.  That is, the definition
# of the function contains the function itself. 

ruby >def first_even_recursive(list)
     |  return nil if list.empty?
     |  i = list.shift
     |  if i.even?
     |    i
     |  else  
     |    first_even_recursive(list)
     |  end  
     |end  
=> :first_even_recursive

ruby >first_even_recursive([1,3,5,66,4,5])
=> 66

# There is another difference between the mathematical defined
# function and the original Ruby one. 
# In the original Ruby fn, we assigned values to the variable 'i'
# and this var changes for each iteration of the loop. 

# In the mathematical function, we do not use any assignment
# inside the definition. AND IF WE DID WE WOULD NOT BE ABLE TO
# MODIFY THE ASSIGNED VALUES

# This is the start of a much bigger idea about the bigger
# idea of mutability and the very fancy-sounding 
# referential transparency.  
## Wikipedia aside

# Referential transparency and referential opacity are properties of parts
# of computer programs. An expression is said to be
# referentially transparent if it can be replaced with its value without 
# changing the behavior of a program (in other words, yielding a program 
# that has the same effects and output on the same input).
# The opposite term is referential opacity.
# While in mathematics all function applications are referentially 
# transparent, in programming this is not always the case
# Referential transparency is one of the principles of functional programming;
# --end--aside--

# Immutablity
# IN the mathematica world, if I say
a =10
# I am NOT assigning a value ffo 10 to a variable
# I am giving a definition of a
a =11 # is WRONG
# This is different from the world of Ruby programming, where
a = 10 
# is an assignment, and this assignment can change. 
# In the mathematial world, when something is defined, this 
# definition cannot be changed. 
a = 10
double_a = a x 2
# In fact a function where a definition contains 'a' is
# exactly the equivalent of a function where a has
# been replaced by its definition

also_double_a = 10 x 2

# This means that the definition of a function cannot change,
# and it cannot be affected by anything else changing.
# So if we call double_a, we know it will always return the
# same result. 

# In general terms, we know that every time we call a function 
# passing in the same values, the output of the function will be 
# the same.  This is referential transparency.  

# This is NOT always the case with Ruby

a = 10
def double_a
 a * 2
end
double_a #=> 20
# but if make change
a = 11 # ...!
# now returns 22.
# In practice, we cannot know the outcome of function just
# by looking at it. We need to know what ASSIGNMENTS have been made.

# Functional programming. Another hallmark.
# It allows you to treat functions as first-class citizens.
# For example
even(x) = x % 2 triple-stroke-equal 0
# now we can use this definition just like any other value.
# Crucially, can pass as arg to another function. 

# Now we can redefine our function to get the first element in list
# making it more generic

                  | nil                      if empty(list)
first(list, fn) = | head(list)               if fn(head(list))
                  | first(tail(list), fn)    otherwise 

# We can use fn as second input and use this function to decide
# whether or not an element is even.

first([1,2,3], even)
# This is a higer order function. Takes another function as input

# Three inportant features that come from mathematical world that
# we will use when doing functional programming
 
#1 Functions are definitions, not a list of instructions
#2 Immutable definitions, not variables
#  (we don't assign values, we define things) 
#  We dont have variables that can change as the program runs
#3 Functions are first-class citizens.
#  Perhaps most important one We can use them anywhere we would use
#  any other variable, including passing in as argument to another
#  function. 
#  Next video looking at first-class functions in real Ruby code
#
#  Map

# Apply discount
ruby >def apply_discount(prices)
     |  discounted_prices =[]  
     |  prices.each do |price|  
     |    reduced_price = price - (price * 0.15)    
     |    discounted_prices << reduced_price
     |  end  
     |  discounted_prices
     |end  
=> :apply_discount

ruby >apply_discount(ruby_prices)
=> [85.0, 63.75, 76.5, 68.0, 42.5]

# Now add tax
ruby >def add_tax(prices)
     |  prices_with_tax=[]
     |  prices.each do |price|
     |    prices_with_tax << price + (price * 0.2)
     |  end  
     |  prices_with_tax
     |end  
=> :add_tax

ruby >add_tax(ruby_prices)
=> [120.0, 90.0, 108.0, 96.0, 60.0]

# At some level of abstraction, the only thing that is different
# is what they do to each price
# Would like to to something like this
ruby >def map(list, fn)
     |  results = []
     |  list.each do | item |
     |    # apply the function
     |  end  
     |end  
=> :map

# Need a way of passing one function to another function.
# Then apply that function to each value

#1 How do we pass one function to another

# One way, create a Proc object

>discount = Proc.new do | price |
     |  price - (price * 0.15)
     |end  
=> #<Proc:0x00000004535c10@(pry):34>
ruby >discount.call(100)
=> 85.0

# now ...

ruby >def map(list, fn)
     |  results = []
     |  list.each do |item|
     |    results << fn.call(item)
     |  end  
     |  results
     |end  
=> :map

ruby >map(ruby_prices, discount)
=> [85.0, 63.75, 76.5, 68.0, 42.5]

# tax
ruby >tax = Proc.new do | price |
     |  price + (price * 0.2)
     |end  
=> #<Proc:0x000000042a97a8@(pry):47>

ruby >map(ruby_prices, tax)
=> [120.0, 90.0, 108.0, 96.0, 60.0]

# But there IS A BETTER BUILT_IN Map function
ruby >ruby_prices.map(&tax)
=> [120.0, 90.0, 108.0, 96.0, 60.0]
ruby >ruby_prices.map(&discount)
=> [85.0, 63.75, 76.5, 68.0, 42.5]

# *** Notice the ampersand! *** 

# For now, think of it as way of telling Ruby that the argument
# contains some code that we want to run

# The funny ampersand character

# In last video, created proc object to pass into a function
# This technique common in Ruby
# Has own special syntax
# Quite often will never use Proc anywhere else!
# Useful to create anonymous proc to use once
# Ruby supports this by allowing you to
# pass blocks of code to methods

ruby >ruby_prices.map(&tax)
=> [120.0, 90.0, 108.0, 96.0, 60.0]

# This is not the usual way of creating and
# using a proc

ruby >ruby_prices.map do |price |
     |  price + (price * 0.2)
     |end  
=> [120.0, 90.0, 108.0, 96.0, 60.0]

# So what does a method that takes a block of code 
# look like?
# Two additional bits of ruby necessary to support blocls

#1 The block of code might be optional
# Can do this using
block_given?

# An example

ruby >def called_with_block?
     |  if block_given?
     |    puts "you called me with a block"
     |  end  
     |end  
=> :called_with_block?
ruby >called_with_block?
=> nil
ruby >called_with_block? do
     |  1 + 2
     |end  
you called me with a block
=> nil

#2 So how do we use a block?
   # The next special method is called 'yield'

# Example one
ruby >def print_and_yield
     |  puts "before calling yield"
     |  yield
     |  puts "After calling yield"
     |end  
=> :print_and_yield

ruby >print_and_yield do 
     |  puts "I am the block"
     |end  
before calling yield
I am the block
After calling yield
=> nil

# Example two
ruby >def print_and_yield_two
     |  puts "before calling yield"
     |  yield
     |  yield
     |  puts "after calling 2 yields"
     |  yield
     |  puts "after calling final yield"
     |end  
=> :print_and_yield_two

ruby >print_and_yield_two do
     |  puts "I am a block of code"
     |end  
before calling yield
I am a block of code
I am a block of code
after calling 2 yields
I am a block of code
after calling final yield
=> nil

# Running a block of code isn't that useful
# We want to be able to pass values into it,
# and get values back in return

# Passing values in is easy: 
# Simply pass them as arguments to yield
# For example to implement our own version of Ruby's built-in each method


ruby >def each_in_list(list)
     |  for i in 0..(list.length - 1)
     |    yield list[i]
     |  end  
     |end  
=> :each_in_list

ruby >each_in_list([1,2,3,5]) do |x|
     |  puts x * 2
     |end  
2
4
6
10
=> 0..3

#2 Using a return value is similarly easy.
# 'yield' returns the value returned from the block

#For example we can write a function that takes a string
# splits the string into a list of words
# passes each word into block
# then adds the result of block to a results array

ruby >def map_words(input)
     |  results =[]
     |  input.split.each do |word|
     |    results << yield(word)
     |  end  
     |  results
     |end  
=> :map_words

ruby >map_words("My name is thomas") do |x|
     |  x.size
     |end  
=> [2, 4, 2, 6]


# Blocks are very common in Ruby, and you will almost always use a block
# when dealing with lists of data
# You will use them much more than you use proc objects directly.
# And certainly much more than 'for' loops for manipulating lists

#In fact, almost all of Ruby's functional influence can be reduced to 
# just saying
  # *** "Use Blocks when dealing with lists of data ***
# More accuretly, perhaps:
  # Ruby's functional influences can mostly be found in the method
  # list of the enumerable module

# But not the full story ...

# Procs and Blocks ..
# There are some great things about Ruby, but the multiple
# syntax options for creating Proc objects is not one of them
# There are a few different way of creating and calling procs
# There is also a lot of overlap between procs and blocks
# They aren't quite the same thing, and they are normally used 
# for different purposes

# Let's start with blocks of code

# We have already seen that you can pass them into methods by
# following the method call by the keyword 'do',
# followed by a parameter list in pipes,
# followed by the code you want to run
# followed by the keyword 'end'

# An example
ruby >prices = [10, 100, 40, 75, 30]
=> [10, 100, 40, 75, 30]

ruby >prices.select do |x|
     |  x < 50
     |end  
=> [10, 40, 30]

# There is also another way to specify a block of code,
# and that is to use curly braces

ruby >prices.select { |x| x < 50}
=> [10, 40, 30]

# *** It is common to use curly braces when the code fits on one line
# and do-end when the code spans multiple lines ***

#2 Proc Objects
# We have already seen how to create this by calling 'new' on the 
# Proc class, and passing in a block of code. 

ruby >cheap = Proc.new do |price|
     |  price < 50
     |end  
=> #<Proc:0x00000004f05a38@(pry):30>

ruby >cheap2 = Proc.new {|price| price < 50}
=> #<Proc:0x00000004f33050@(pry):34>

# There a  few different ways to call a proc
#1 As already seen, you can send the message 'call' to it.
ruby >cheap.call(100)
=> false
# Any parameters given to 'call' are assigned to pararmeter list

#2 You can also follow the name of the proc object by a list of arguments
# wrapped in square brackets
ruby >cheap[100]
=> false
# This is identical to sending the message 'call' to the proc

#3 Can also send a pair of parentheses as a message to the proc, making
# it look a bit like a method call. John thinks this just looks wrong!
# He recommends to stick using 'call' explicitly, or using square 
# bracket syntax.

# Proc objects and Lambdas.
# Lambda comes from Lambda Calculus
# Developed in 1930s and hugely influential in computer science

# Can create a lambda using the keyword 'lambda' followed by a block

#The object returned is just a special type of proc eobject
# You can call it in the same way you call any other proc

ruby >cheap = lambda {|price| price < 50}
=> #<Proc:0x00000004ee69f8@(pry):37 (lambda)>
ruby >cheap.call(100)
=> false

ruby >[100, 40, 30, 2, 100].map(&cheap)
=> [false, true, true, true, false]

#Since Ruby 1.9, there is a new way of writing lambda
#1 arrow pointing right
#2 followed by parameter list
#3 followed by block 

ruby >cheap = -> price { price < 80}
=> #<Proc:0x00000004db5728@(pry):41 (lambda)>

ruby >[70,80,80].map(&cheap)
=> [true, false, false]

# *** Note how parameter list IS MOVED OUT OF THE BLOCK and 
# immediately follows the arrow ***

# This also OK
ruby >cheap = -> (price) { price < 10}

cheaptest = -> price1, price2 { [price1, price2].min}

# lambdas written in this way are called STABBY LAMBDAS

# Very succinct syntax

# Lambdas and Procs behave slightly differently as regards checking of arguments

ruby >p = Proc.new { |x| "You called me with #{x.inspect}"}
=> #<Proc:0x0000000289f880@(pry):49>
ruby >p.call("begorrah")
=> "You called me with \"begorrah\""
ruby >p.call
=> "You called me with nil"

ruby >l = -> x { "You called me with #{x.inspect}"}
=> #<Proc:0x00000004ac0608@(pry):52 (lambda)>
ruby >l.call("begorrah")
=> "You called me with \"begorrah\""
ruby >l.call
ArgumentError: wrong number of arguments (0 for 1)
from (pry):52:in `block in __pry__'


# Notice that calling the lamda-proc without any arguments gives rise to argument
# error. John recons that is what want most often.  

# Lets go back to blocks again
# When we write a method that takes a block, we can assign that block
# to a parameter using some special syntax

# *** -- You can specify an optional final parameter to hold the block
# prefixed by an ampersand *** --

ruby >def modify_prices(prices, &block)
     |  block.inspect
     |end  
=> :modify_prices

ruby >prices =[10, 100, 89]
=> [10, 100, 89]

ruby >modify_prices(prices) { |p| p * 1.2}
=> "#<Proc:0x00000004058be8@(pry):6>"

# We can see that the block  parameter is now actually a proc!!
# How consistent of Ruby!
# Does this mean we can just pass a proc object in as the final parameter
# Well NOT QUITE!
# Blocks are a very syntatic form in Ruby.
# So if you try to pass in a proc object, in this case a stabby lambda
# the Ruhy interpreter does not quite understand what is going on, and
# thinks we have passed in too many arguments

ruby >add_tax = -> prices { prices * 0.2}
=> #<Proc:0x00000004083e38@(pry):8 (lambda)>

ruby >modify_prices(prices, add_tax)
ArgumentError: wrong number of arguments (2 for 1)
from (pry):1:in `modify_prices'

ruby >modify_prices(prices, &add_tax)
=> "#<Proc:0x00000004083e38@(pry):8 (lambda)>"

# John has never called a method like this, but 
# at least we now know how!

# *** Howerver, this trick does get interesting when used with
# an interesting method on the symbol class.

# You can send a message to_proc to any symbol 
# for example, the symbol :even?, and it returns a proc object
ruby >:even?.to_proc
=> #<Proc:0x000000040d9db0>

# The proc that gets returns takes a sinle parameter, 
# then tries to call a method matching the original symbol
# on that parameter. 

# For example: 
ruby >:even?.to_proc.call(4)
=> true
ruby >:even?.to_proc[4]
=> true

# This will not work
ruby >:even?.to_proc.call("hello")
NoMethodError: undefined method `even?' for "hello":String
from (pry):16:in `call'

# *** What this gives us then is a shorthand method for
# creating a proc which just says: 'call this message on
# a  value'

# For example, say we have a list of prices and we want to 
# find which ones are even

ruby >prices = [75, 100, 4, 3]
=> [75, 100, 4, 3]

ruby >prices.select { |p| p.even?}
=> [100, 4]
# Shorthand
ruby >prices.select(&:even?)
=> [100, 4]
# We pass in symbol-even? and prefix with ampersand.
# Ampersand doing two things
#1 Firstly, calling to_proc on the symbol for us
#2 Also tells Ruby that this proc will act like a block
#  being passed to the method

# This gives us a very succinct way of calling a single method
# on a list of objects

# For example (**goodies**)
ruby >prices.map(&:to_f)
=> [75.0, 100.0, 4.0, 3.0]

ruby >prices.map(&:to_s)
=> ["75", "100", "4", "3"]
 
# In practice we will use blocs and lambdas a lot
# When to use which?
# Use a block when you are calling a method and expect 
# the code you are passing in to be run as part of the method
# Use a lambda when you want to store a block of code and use it
# later. Maybe when you want to delay execution until later.
# Will probably use the clever &:tosymbol trick quite a lot
# when you want to call a single method on a list of objects.

# Lambdas can be used for a lot more ... read on.  

# Currying.

# In this video we will look at partial application, also known
# as currying. 
# This allows us to call a proc with some arguments now, and with
# the rest of the arguments  later. 

# -- wikipedia aside
# In mathematics and computer science, currying is the technique of 
# translating the evaluation of a function that takes multiple arguments
# (or a tuple of arguments) into evaluating a sequence of functions,
# each with a single argument. It was introduced by
# Moses Schönfinkel[1][2][3] and later developed by Haskell Curry
# -- end aside --

# First developed by Schonfinkel, but Curry first applied to lamda
# calculus

# Lets say we have a Proc that multipies two numbers together
ruby >mult = -> x, y {x * y}
=> #<Proc:0x000000051dd9e0@(pry):8 (lambda)>
ruby >mult[2,3]
=> 6
ruby >mult.call(2,3)
=> 6

# can also Curry
double = mult.curry[2]
=> #<Proc:0x0000000522b780 (lambda)>

ruby >double[3]
=> 6
ruby >double[8]

# So why would we use Currying?
# Let's look at a simple example



# we use square brackets with Curry to let Ruby know that the
# argument are for the original Proc

# Lets say we have an e-commerce platform in Ruby
# We want to run some promotions sometime

ruby >class Promotion
     |  def initialize (description, calculator)
     |    @description = description
     |    @calculator = calculator
     |  end  
     |  def apply(total)
     |    total - @calculator[total]
     |  end  
     |end  
=> :apply

# Create promotion class with description and with
# proc to calculate promotion amount.

# For example, to discount everything by 15%

ruby >discount = Promotion.new(
     |  "15% off everything",  
     |  -> total {total * 0.15}
     |)  
=> #<Promotion:0x00000003fa2730
 @calculator=#<Proc:0x00000003fa2758@(pry):12 (lambda)>,
 @description="15% off everything">


# The problem comes when we have to create many different
# promotions that work in similar ways.

# Lets say our promotion deducts 10% if you spend over $50
# and 15% if you spend over 100 dollars

ruby >ten_pc = Promotion.new(
     |  "10% if you spend over fifty dollars",
     |  -> total {total > 50 ? total * 0.1 : 0}
     |)  
=> #<Promotion:0x00000005293a88
 @calculator=#<Proc:0x00000005293ab0@(pry):18 (lambda)>,
 @description="10% if you spend over fifty dollars">

ruby >ten_pc.apply(45)
=> 45
ruby >ten_pc.apply(100)
=> 90.0

ruby >fifteen_pc = Promotion.new(
     |  "15% if you spend more than 100 dollars",
     |  -> total {total > 100 ? total * 0.15 : 0}
     |)  
=> #<Promotion:0x000000052fd280
 @calculator=#<Proc:0x000000052fd2a8@(pry):24 (lambda)>,
 @description="15% if you spend more than 100 dollars">

ruby >fifteen_pc.apply(45)
=> 45
ruby >fifteen_pc.apply(100)
=> 100
ruby >fifteen_pc.apply(150)
=> 127.5

# But the calculators we are using here are pretty similar.
# The only differences are the values involved

# Lets create a more general calculator and Curry it with the values 
# we want

ruby >calc = -> threshold, discount, total do
     |  total > threshold ? total * discount : 0
     |end  
=> #<Proc:0x000000053c6338@(pry):30 (lambda)>

ruby >ten_pc_calc = calc.curry[50, 0.1]
=> #<Proc:0x000000053db530 (lambda)>
ruby >fifteen_pc_calc = calc.curry[100, 0.15]
=> #<Proc:0x000000053dc3e0 (lambda)>

ruby >ten_pc_calc[45]
=> 0
ruby >ten_pc_calc[50]
=> 0
ruby >ten_pc_calc[100]
=> 10.0
ruby >fifteen_pc_calc[100]
=> 0
ruby >fifteen_pc_calc[150]
=> 22.5
# now ...
# can use in our promotions. 
                                  ^
ruby >ten_pcc = Promotion.new(
     |  "10% if you spend over 50 dollars",
     |ten_pc_calc)  
=> #<Promotion:0x000000051a84c0
 @calculator=#<Proc:0x000000053db530 (lambda)>,
 @description="10% if you spend over 50 dollars">

ruby >ten_pcc.apply(100)
=> 90.0

ruby >fifteen_pc = Promotion.new(
     |  "15% if you spend over 100 dollars",
     |  fifteen_pc_calc
     |)  
=> #<Promotion:0x00000005095858
 @calculator=#<Proc:0x000000053dc3e0 (lambda)>,
 @description="15% if you spend over 100 dollars">

ruby >fifteen_pc.apply(150)
=> 127.5
 
# Currying allows us to write very generalized functions that may be
# specialized in our problem domain

# Functional Composition

# Just a fancy way of saying 'joining functions together'
# Illustrate refactoring some code
# Lets say we work for e-commrece and we have been asked to report on
# how well the products are selling.

products.sample
Product price =10, rating =1, color=:green, sales =2251

# inject
# takes a single parameter for an inital value
# Then it takes a block with two parameters
# The first parameter is result of the last time the block was run
# OR the intial value when it first runs :  
# The second parameter gets set to each item in our array
# and then the block gets run once per product

# -- inject/reduce aside

# #inject and #reduce are the same thing in Ruby. Also called
# fold in other programming languages.

# map and collect are also idential

# see here
# http://stackoverflow.com/a/13813295/499167

ruby >[1,2,3,4].inject(100) {|a,b| a + b}
=> 110
ruby >[1,2,3,4].inject(&:+)
=> 10
ruby >[1,2,3,4].inject(100, &:+)
=> 110
ruby >[1,2,3,4].reduce(100, &:+)
=> 110
# --end of aside --


# Products Report  - Basic

ruby >class Report
     |  def initalize(products)
     |    @products = products
     |  end  
     |  
     |  def run 
     |    money_taken = @products.inject(0) do | total, product |
     |      (product.price * product.sales) + total
     |    end  
     |    
     |    total_sales = @products.inject(0) do | total, product |
     |      product.sales + total
     |    end  
     |    
     |    money_taken / total_sales
     |  end  
     |end  
=> :run

# Now lets say there is a run on Red items ...

ruby >class Report
     |  def initalize(products)  
     |    @products = products    
     |  end    
     |  
     |  def run(red_only: false)
     |    selection = @products
     |    
     |    if red_only
     |      selection  = selection.select {|product| product.color == :red}
     |    end  
     |    money_taken = @products.inject(0) do | total, product | 
     |      (product.price * product.sales) + total      
     |    end      
     |    total_sales = @products.inject(0) do | total, product |
     |      product.sales + total      
     |    end      
     |    
     |    {
     |      averarge_sales_price: money_taken / total_sales,
     |      money_taken: money_taken
     |    }  
     |  end  
     |end  
=> :run

# Now want to report top-selling methods

ruby >class Report
     |  def initalize(products)  
     |    @products = products    
     |  end    
     |  def run(red_only: false)  
     |    selection = select_products(red_only)    
     |    money_taken = @products.inject(0) do | total, product |    
     |      (product.price * product.sales) + total      
     |    end      
     |    total_sales = @products.inject(0) do | total, product |    
     |      product.sales + total      
     |    end      
     |    {    
     |      averarge_sales_price: money_taken / total_sales,      
     |      money_taken: money_taken      
     |    }      
     |    def top_selling(red_only: false)    
     |      select_products(red_only).sort_by(&:sales).last(3)      
     |    end      
     |    def select_products(red_only)    
     |      selection = @products      
     |      if red_only      
     |        selection = selection.select { | product | product.color == :red}        
     |      end        
     |      selection      
     |    end      
     |  end    
     |end  
=> :run

# So how can we avoid things getting out of control?

# Lets create a lambda to create average sales price

ruby >avg_sales_price = -> products { sales_value[products]  / total_sales[products]}
=> #<Proc:0x00000004ab91f0@(pry):197 (lambda)>

ruby >sum = -> list {list.inject(&:+)}
=> #<Proc:0x0000000497df48@(pry):198 (lambda)>

ruby >sales_value = -> products do
     |  product_revenue = products.map { | product | product.sales * product.price }
     |  sum[product_revenue]
     |end  
=> #<Proc:0x00000004a367a0@(pry):202 (lambda)>

ruby >total_sales = -> products { sum[products.map(&:sales)] }
=> #<Proc:0x00000004982ef8@(pry):206 (lambda)>

ruby >red = -> products { products.select { |p| p.color == :red}}
=> #<Proc:0x00000004b07990@(pry):208 (lambda)>

# Now, create FunctionalReport Clas

ruby >class FunctionalReport
     |  def initialize(products, *fns)  
     |    @products = products    
     |    @fns = fns    
     |  end    
     |  def run  
     |    @fns.inject(@products) do | last_result, fn |
     |      fn[last_result]
     |    end  
     |  end  
     |end  
=> :run

# Now can do something like this

ruby >FunctionlReport.new(PRODUCTS, avg_sales_price).run 

ruby >FunctionlReport.new(PRODUCTS, red, avg_sales_price).run

ruby >green = -> products {products.select { |p| p.color == :green}}
=> #<Proc:0x000000048e91b8@(pry):234 (lambda)>

ruby >high_rating = -> products {products.select { |p| p.rating >= 3}}
=> #<Proc:0x00000004999220@(pry):235 (lambda)>

ruby >FunctionalReport.new(PRODUCTS, green, high_rating, total_sales).run

# But still quite a bit of repetition 
#Build generic function to select products by some attribute
#and then use currying to create specific queries

ruby >by_attribute = -> attr, op, value, products do
     |  products.select { |p| p[attr].send(op, value) }
     |end  
=> #<Proc:0x00000005836a80@(pry):1 (lambda)>

ruby >by_color = by_attribute.curry[:color, :==]
=> #<Proc:0x0000000585ea80 (lambda)>

ruby >blue = by_color.curry[:blue]
=> #<Proc:0x00000005882890 (lambda)>

ruby >blue[PRODUCTS].take(3)
NameError: uninitialized constant PRODUCTS
from (pry):7:in `__pry__'

ruby >by_max_rating = by_attribute.curry[:rating, :<]
=> #<Proc:0x000000058a6100 (lambda)>

ruby >low_rating = by_max_rating.curry[3]
=> #<Proc:0x000000058c9da8 (lambda)>

 # But should we write code like this?

# Fuunctional thinking

# Advantages of Functional Programming
#1    Add features without changing existing code
#2    Create each step of report with very little code
#3    No need to write unrelated code from other steps

# but ... not very 'Ruby-ish'
# Clojure is a 'proper' functional programming language

# Recommended functional techniques

map, select, inject ...

blocks for lists of data

lambdas for code to be run later


# but ...
currying, composing lambda
# will be used only rarely, maybe?

#  the red product filter implemenented a short piece of specific functionality, but 
# it also treats the data as being immutable - a characteristic of functinla programming. 

# Immutability and referential transparency make it much easier to reason about code
#
# Final Module
# Metaprogramming

# In Rails

class Post < ActiveRecord::Base
    has_many :comments
    belongs_to :user
end

# 'has_many' and 'belongs_to' are really just Ruby method calls. 
# but they are calls to methods that will spit out new ruby code
# In this casss they both add extra methods to your active record model to help
# you accss other associated collections or classes 

# These are also class methods.  That is, they get evaluated when the
# class is defined. 
#
# Online dating app for dinosars

# The only thing you see is describing what we want to achieve
# The start of a bigger idea: DSL 
#
# DSL is Domain-specific language
# A good DSL will make the underlying programming language disappear
# into the background. 

# class instance variables

# -- stackoverflow aside

# Class variables are shared between a given class and its subclasses.
# Class instance variables belong to exactly one class; its subclasses
#  are separate.
# -- end aside --

# Classes in Ruby are just objects.  A subclass is a different object
# Class instance variables are just instance variables with the 
# same syntax as instance variables. The only difference is that we
# call from inside class methods. 

# Ruby is a powerful language
# Ruby is not a simple language

#  The power of Ruby comes from three ideas

#1 Object Orientation
#2 Functions
#3 Metaprogramming 
#  (Dynamic nature controlled throught metaprogramming) 

# -- the end 


## tgd currying aside ---

ruby >addtwo = -> (x, y) {x +y}
=> #<Proc:0x00000004a61f40@(pry):245 (lambda)>
ruby >addtwo.call(100,2)
=> 102
ruby >plustwo=addtwo.curry[2]
=> #<Proc:0x00000004af2450 (lambda)>
ruby >plustwo[89]
=> 91
ruby >

 addtwoalt = lambda {|x,y| x + y}
 addtwoalt.call(100,2)
 addtwoalt[100,2]
 plustwoalt = addtwoalt.curry[2]
 plustwoalt[100]


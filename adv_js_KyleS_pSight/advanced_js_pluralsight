# Advanced JavaScript Pluralsight
# Front End Masters Workshop Series
# Kyle Simpson
#Scope and the Javascript Compiler
# Scope - where to look for things
# What are we looking for?
# The variables we reference
# Where is that variable?
# Where was he declared?
# We are looking for lexical identifiers (variables)
# Who is doing the looking?
# Need to look at through the eyes of compiler
# First myth he wants to dispel is that JS is the statement that 'JS is NOT a compiled language'
# For those of you who were under the impression that there isn't a compiler involved ....
# But compilation in JS not quite the same as for, say c++
# One difference is that we don't send out (distribute) the binary compiled form
# We send out the souce code.
# In a sense JS is compiled, but it is compiled every single time it is run
# BASH is an interpreted language.
This means that when it is running line 4 it has no idea what is on line 5
# Interpreter literally goes form top-to-bottom
# In a compiled language (including JS), the compiler does an initial pass through the code, 
# and then does at least one more pass

# So it HAS seen line five before it executes line 3. 

# The basic unit of scoping in JS is the function (not STRICTLY correct ...) 
# The smallest atomic unit of scope is the function.

#1	var foo = "bar";
#2
#3	function bar() {
#4		var foo = "baz";
#5		} 	
#6
#7	funcion baz(foo) {
#8		foo = "bam";
#9		bam = "yay";
#10	}

# Compiling of Function Scope

# Need to start thinking like the JS engine
# One important function of compiler pertinent to our discussion
# - finding declarations of variables and functions 
# and putting them into their appropiate scope slots
# JS code will get a first pass through the compiler, and
# a few microseconds later it will be passed  through again where it is executed

# Line 1 is a variable declaration
# Most  people will think of that as a single JS statement
# Gramatically, that is true!
# However, that is not how JS treats it ...
# Need to look at as two entierely separate operations. 
# Declaration and initialization.
# Both different AND DONE AT DIFFERENT TIMES
# Declaration var foo
# Initialization foo="bar"

# Compiler will first do a single pass looking for all the var AND function declarations.
# ANTHROPOMORPHISE
# Let's talk to the JS engine
# First line. Compiler " I see a variable declaration for an identifier called 'foo'
# Which scope am I in? => The global scope
# Ok I'll register my foo identifier into global scope. 
# Let's move on..
# Line 3.  I see a function declaration with an identifier named 'bar'
# Register the function 'bar' into global scope
# JS compiler, unlike C++, makes 'best guess'
# Lets compile function.. 
# Line 4. Variable declaration for foo
# In scope of bar
# We have now compiled the function var
# Line 7.  A function called baz
# Add function call 'baz' to declaration list for global scope
# Recursively enter 'baz' and compile
# Where is next declaration?
# It is 'foo', in scope of 'baz'
# 'Hey baz', register declaration of var called 'foo'
#  THERE ARE NO MORE DECLARATIONS
# We are now done
# Declared
foo	global
bar global
foo baz
baz global
foo baz
# Let's assume the code is executed...
# A couple of microseconds later...
# First things first. 'var' no longer exists
# Line 1; foo = "bar"
# Let's execute line 1
# Need to introduce some compiler terminology.
LHS
RHS
# LHS and RHS of what?
# Of an assignment!
# 'foo' is an LHS reference
# Come from LHS and RHS of equals sign
# But there are other ways for assignments to occur
# which don't have an equals, but LHS and RHS still apply.
# Broaden our definitions...
LHS is the target
RHS is the source
# Ask scope manager: 'Hey, global scope, I have an LHS
# reference for a var called foo.  Have you ever heard of it?
# Scope manager: Yes, I've heard of him.  You declared him just a couple of microseconds ago
# Execution of Function code
# Lets execute bar
# Line 4 ...
# Hey scope of bar, I have an LHS reference  for the var foo
# Ever heard of him?
# Scope manager: Yes, you declared him a couple of microseconds
# ago. Hands back a reference
# So we can take value and copy it into that location. 
# Now execute function baz
# Line 8 ...
# Hey, scope of baz, I have an LHS reference for a var called
foo.  Ever heard of him? (Do you have a reference for him?)
# Answer: It's in my definition. I have a parameter called foo
# Hands back a referece in the local scope of baz
# Can do assignment.
# (We asked local scope first)
# But now comes line nine
# Hey, scope of baz, I have an LHS ref for variable called
# 'bam'.  Ever heard of him?
# scope of baz: "Go Fish"
# Let's assume we are not in strict mode
# We no go out one level of scope
# In this case, global scope
# Hey scope of global, I have an LHS referencce for a variable
# called bam. Ever heard to him?
# global scope:  Yes! I've just created it for you!
# Created in the global scope
# This does NOT happen in strict mode. 
# This behaviour only happens with LHS reference
# So the assignment is to GLOBAL variable. Ouch!
# In strict mode, the answer is "No, never heard of him"
# and throws an error.
# If undeclared, unable to find that ref in any scope we
# have access to.  Different from undefined, which IS declared,
# and is an actual value. 
# An undeclared variable means we cannot find an LHS ref to is
# in any of scopes to which we have access. 
# UNDEFINED
# undefined and undeclared very different.  Undefined means that
# it WAS declared but has special empty value which was 
# (mistakenly?) called undefined.  Unitialized might be more appropiate.  
	://github.com/tomGdow/skeptics_SPA_angular.git
#var keyword declares a variable

# Scope and Execution Example
#1 var foo = bar
#2
#3  function bar () {
#4		var foo = "baz"
#5
#6		function baz(foo) {
#7					foo = "bam";
#8				bam = "yay";
#9		}
#10   baz();
#11
#12
#13 bar();
#14 foo;
#15 bam;
#16 baz();
#
# Compile ...
# Line 1: declare foo in global scope
# "Hey, global scope, I have a declaration for a variable called foo"
# "Got it"
# Line 3: declare function bar in global scope
# "Hey global scope, I have a function call bar I want to declare"
# "OK, got it, declared in bar scope. 
# Recognize as function. Now recursively descend in and compile fn
# Line 4:  declare var foo in bar scope
# Hey bar scope, I have a declaration for a var called foo"
# "OK, got it, declared in bar scope.
# line 6 declare function baz in bar  scope
# "Hey scope of bar, I have a function declaration for the fn baz
# "OK, got it, delcared in bar scope.
# line 6.5 declare var foo in baz scope
# "Hey scope of baz, I have a named parameter for  the function baz
# OK got it, declared in baz scope
# No more declarations
# A couple of microseconds later.  Lets go and execute!!
# line 1: Hey global scope have LHS reference to var called 'foo', EHOH?
# Yes, has been declared in global scope
# Make assignment
# Lines 3 -11 don't exist anymore as they have been compiled away!
# On to line 13...
# The reason its an RHS reference  is because it's not a LHS!
# There is not an  assignment going on.  The bar reference is
# not being assigned to, it is being used.
# So on line 13 ..
# "Hey global scope, I have an RHS reference for a variable called bar.
# EHOH?
# "Yes, it was defined in line 2. So I can retrive that value"
# And it is a function object
# Now I see open/closed parentheses on L13.  Good News ....
# Attempt to execute the function 
# so ... line 4
# "Hey, bar scope I have an LHS ref for a var called foo. EHOH?"
# "Yes, here is the reference from the bar scope"
#  Lines 6 -9 not there anymore as they have been compiled away!
#  So... execute line 10
#  "Hey, bar scope I have a RHS reference for a var called baz, EHOH?
#  "Yes, he was created on line 6 ...
#  So lets execute baz ...
#  Line 7," I have a LHS reference for  a var called foo, EHOH?"
#  "Yes, you declared him on line 6"
#  "Lets make the assignment to foo in the baz scope"
#  Lets execute line 8
#  "Hey, scope of baz, I have a LHS assignment for a var called bam, EHOH?"
#  "No, go fish"
#  "Hey scope of bar, I have a LHS assignment for a var called bam, EHOH?"
#  "No, go fish"
#  "Hey, global scope, I have a LHS assignment for a var called bam, EHOH?
#  "Yes, I've just created him for you" 
#  "Make assignment".  
#  function returns "yay"
#  (This silly behaviour is removed in strict"
#  So now lets execute line 14;
#  Hey, global scope, I have a RHS reference for a var called foo. EHOH?
#  "Yes, declared in line 1
#  "foo has value of "bar"
#  Now line 15...
#  "Hey, global scope, I have a RHS reference for a var called bam, EHOH?
#  "YES! returns "yay"
#  Now line 16 ...
#  Hey global scope, I have a RHS ref or a var called baz, EHOH?
#  "No!, and I do not declare RHS references"
#  REFERENCE ERROR! 
# True for both strict and unstrict
#
# Function Declarations and Function Expressions
		var foo = function bar () {
		var foo = "baz"
		function baz(foo) {
		foo=bar;

		foo;
		}
		baz();
		};

		foo();
		bar();

#Difference between function DECLARATION and function EXPRESSION is that
# in a function declaration the 'function' keyword is the fires word in the JS
# statement.  Not the first thing on the line. The first thing on the statement.
# It is is NOT, then we are dealing with a functional expression. 
# Often see FE as anonymous functions. 
# Above is a NAMED function expression, because we see a name in the identifier position.
# 'function bar'. 
# But because we are dealing with a FE, function bar does not get declared in outer scope. 
# Instead is declared in its own scope.  So name bar exists from lines 1-9 inside of 
# itself. But try to call bar in line 12, clearly does not exist Get ref error. 
# Three major criticisms of anonymous FE
#1 No way inside of function to refer to ourselves.. For recursion, say. 
# By adding name 'bar' have the ability to reference ourselves
# The 'this' keyword is NOT a reference to yourself. 
# The name is also safe.  Does not pollute the outer scope.
#2 Anonymous functions do not play well in debugging!
# A name will always get used in debug stack traces
#3 It self-documents code. Give it a nice descriptive name like 'handler'

# It was stated previously that the function is the only atomic unit of scope.
# Turns out, not strictly true.  As of ES3 ('way back in the days'), when 'try/catch'
# was added to the language, it was specified that the 'catch' clause was block scoped.
		var foo;
		try {
			foo.length:
		}
		catch (err) {
			console.log(err);  // Type Error
		}

		console.log(err); // Reference Error

#caveat. IE6 screwed this up .. but as of IE7 and all other browsers, all OK

# Lexical Scope
# Two models for scoping. Lexical and dynamic.
# Lexical is most common.
# Dynamic not present in JS, but a good eg of language with dynamic scope is BASH
# Perl: can 'opt-in' to have Dscope.
# Vast majority of languages use lexical scope.
# What is lexical scoping?
# Fancy term, really ...
# 'lex' refers to the parsing stage called 'lexing' that occurs in the compiler. 
# Lexical scoping is 'compile time scope'.  All decisions for scoping, and who can see what were
# make at compile time and are cast in stone.  
# Compiler decides what your scope is.
# We have already seen that ...
# Lexical scope like a block of flats.
# If scope not on first floor, go up to next floor
# top floor is global scope.
# Can also think of Lscope as a series of NON-OVERLAPPING nested bubbles.
# Not like venn-diagrams where bubbles can overlap.
# Lscope are author, compile-time decisions. 
# Nesting is fundamental part of Lscope.
# Lscope cannot change. compiler knows ahead of runtime exactly what the scope is.
# Cheating Lexical Scope: Eval
# First way of cheating lexical scope is with eval!

#1	var bar ="bar";
#2
#3		function foo(str) {
#4	 	eval (str);
#5		console.log(bar)
#6	}
#7
#8	foo("var bar =42;"); 

# 'eval' takes any given string and evaluates it as code. 
# The function has no var called 'bar' in it!  So when execute line
# five, would expect JS to go to global scope and get bar from there.
# But because we choose to pass in a variable declaration in the form of a string
# and eval runs on line 4, it 'cheats' things and it pretends that that type of code
# had existed at compile time.  In a sense it modifies the existing lexical scope of foo
# to add a new declaration to it at run time. 
# When you start 'cheating' the optimizations in the JS engine, your code goes slower.
# Has to assume it cannot optimize those lookups. It has to assume that in the worst case
# you are going to invalidate those assumptions. 
# Just by having eval present, your code will run slower.
# But as of strict mode, a whole new scope is created for the 'eval' statement.
# Strict mode is not just about making better code, it is about making more optimizable code
# If you have to ask is it Ok to use 'eval', the answer is no!

#There is an even worse way to cheat lexical scope. - The 'with' keyword

		var obj = {
a: 2,
	 b: 3,
	 c: 4,
		};

		//obj.a = obj.b + obj.c;
		//obj.c = obj.b + obj.a;

		with (obj) {
			a = b + c;
			c = b - a;
			d =3; 
		}

		console.log(obj.a);  // 7
		console.log(obj.b);  // 3
		console.log(obj.c);  // -4
		console.log('-----');
		console.log(obj.d);// undefined
		console.log(d);    //3 !!


# So what happens when I run line 13?
# KEY:  With statement is treated as a lexical scope.
# will behave by the exact same rules of lexical scoping we 
# "Hey scope of with statement obj, have you got a LHS ref to a 
# var called d?
# No, go fish
# Go to outer (global scope). Hey global scope do you have a LHS ref
# to a variable called 'd'.  Yes! I have created one for you
#
# Hey object, gotta reference to a global variable called "d"?
# No, go fish
# An auto-global has been created!!
#  
# 'with' arguable worse than 'eval', as 'with' creates a whole 
# new lexical  scope at runtime whereas 'eval' merely modifies an
# existing lexical global scope. 
# When the compiler sees a 'with' keyword, it assumes the worst!! 
# disables many optimizations.
# As of 'strict' mode,  'with' keyword is completly disallowed
# altogether. 

#IIFE Pattern
		(function () {
# I am an IIFE skeleton
		 })();

		var foo ="foo"
			(function () {
			 var foo = "foo2"
			 console.log(foo) // foo2
			 })();
		console.log(foo) // foo

# Why? Want to wrap lines 5 & 6 in new scope.
# In JS, the unit of scope is function
# In other languages could use a pair of curly braces
# No leakage of function name ... 
# IIFE expression.  Wrap in parentheses to make an expression.  If
# opening paren wasen't there would have function DECLARATION
# Another set of parens at end immediately executes an expression. 
# This pattern is extremely popular.  In top two in all of JS
# For long time had it without name.  In 2009, 2010 or sometime like that
# Ben Alman, "cowboy" online coined the term.
# "Mr jQuery plugin'.
# Suggested the name "Immediately invoked function expression" IFFE
# Key. A function EXPRESSION, either named or anonymous, that immediately
# invokes itself. 
# If, say you have 100 functions and want to keep 99 private.
# Wrap in an IIFE.  Now all 100 are private. Now take one and add as property
# to window object, say,  to make it global. 

# Useful Variations on the IIFE pattern
#1 An IIFE is just a function call, so we can pass things into it.

			var foo ="foo"

			(function(bar) {
			 var foo =bar;
			 console.log(foo)
			 })(foo);

		console.log(foo);

#Kyle Simpson passes in the window object but calls it global.  Makes things obvious. 
# Another use in jQuery world. If you are worried that the '$'sign legitimately
# point to the jQuery object, pass in ... )(jQuery); but on line 3 call it as dollar
# (function($) {
# // I am am IIFE 
# })(jQuery); 

#IIFE Questions 
#Block Scope in ES6
# The 'let' keyword.
# Kind of like 'var'.  Will declare a variable, but will
# implicitly attach that variable to whatever block it appears in.
# Rather than attaching it to the function

		function foo () {
			var bar = "bar"
				for (let i =0; i < bar.length; i++) {
					console.log(bar.charAt(i)):
				}
			console.log(i);

		}

		foo();

# A usual way with JS developers
# for (var i =1; ...) 

# If had said for (var i = 0; ...) on line 3 above then 
# i would have attached TO THE FUNCTION. 
# (let i =0;...) makes it attach to for loop
# Same occurs if put let inside of 'if' statement.

		function foo (bar)
			if (bar) {
				let baz = bar;
				if (baz) {
					let bam = baz:
				}
				console.log(bar); // Error
			}
		console.lgo(baz); // Error
}
foo ("bar");

# 'let' keyword will hijack implicitly the scope of whatever block it appears in.
# Usually that is any two(?)  pairs of curly braces. 
# Not just styleistic benefits of 'let'.  Also potentially more
# efficient garbage collection.

# Problems with the 'let' keyword
# Problem 1.  The 'let' keyword does not hoist.
# Problem 2.  Another mental task for refactoring.
# One way around problems with let is to create a let block (rather than a let 
# declaration as shown in the code above)
# CAREFUL!  Read on ...

function foo(bar)
	let (baz = bar) {
		console.log (baz); // "bar"
	}
console.log(baz); // Error
}
foo ("bar");

# Create an explicit block for the binding to exist, and it only 
# exists within that block. 
# Forces declarations to top of block. 
But MAJOR problem   The TC39 committee decided to REJECT the above syntax from ES6!!
# For his solution let-er 
# See
https://github.com/getify/let-er
https://gist.github.com/getify/5285514
https://gist.github.com/getify

# In JS you CAN create an idiomatic block with two curly braces. 

# Dynamic Scope
# A THEORETICAL example of dynamic scope
function foo() {
	console.log(bar);  //dynamic!
}

function baz() {
	var bar = "bar";
	foo();
}
baz();
# When we reference var bar on line 2 we can clearly see
# the LEXICALLY bar does not exist.  
# But if dynamic scoping were the model used by JS then
# it would not look at where the code was written, but would
# instead look at the calls stack. 
# It would say "Does function foo have a bar, and IF NOT where was
# function foo called from?
# It would go one step up the call stack and see that it is called from baz.
# So look at the scope of baz to see if there was a variable.
# Should look awkward...
# Lexical scoping in 99.9% of all languages.
# The key distinction is that in dynamic scoping the decision for
# how scoping works is a run-time decision, as opposed to in lexical 
# scoping it is an author time decision. 

# Quiz Scope.
#1 What type of scoping rules does JS have? Exceptions?

#a JavaScript has lexical scoping. 
#b We can 'cheat' lexical scoping using
#eval and
#with

#2 What re the different ways you can create a new scope? 
#a The function is the fundamental unit of scope
#b The catch clause has block scope.
#c The let keyword may be used to obtain block scoping. 

#3  What is the difference between undeclared and undefined?
# Undefined IS a value and a variable with a value of undefined has
# been declared.  Undefined, conceptually, means the var does not 
# currently have a value. 
# Undeclared means the var has not been declared. ie it has not been
# registered in any scope.  If a var is not declared you will get
# back  a 'reference error'.

# Hoisting 
# There is a conceptual model for how JS works. This CM is called hoisting.
# No ref in JS spec to hoisting.  Hoisting is a mental construct designed 
# to help us understand how JS behaves. 

a;  // Undefined (NOT undeclared)
b;  // Undefined
var a = b;
var b = 2;
b;  // 2
a;  // Undefined

# Best to think of code as written as follows just before execution
var a; 
var b;
a;
b;
a = b;
b = 2;
b;
a;

# Think of as variable declarations 'moved' to top, but assignments are left in
# place. Moving to the top is called hoisting. 
# Think of lines 1 & 2 as compile phase.
# Execution phase is lines 3-8. 
# How will this code work?
var a = b();
bar c = d();
a;
c;
function b() {
	return c;
}

var d = function () {
	return b():
};

# Proper way to think of code using hoisting concept.

function b() {
	return c;
}
var a;
var c;
var d;
a = b();
c = d();
console.log(a);
console.log(c);

d = function () {
	return b();
};




# skdfjasl
var a = b();
var c = d();
console.log(a);
console.log(c);

function b() {
	return c;
}

var d = function () {
	return b();
};




function b() 
	var a
	var b
	var d
	a = b();
	c = d();
	d = funcion () {..}

# Kyle shies away of thinking about code in terms of hoisting
# Thinking in terms of compiler, LHS, etc preferable

# So cannot call a function expression before it has been given its value.
# Note that in above the function b got hoisted first.

# Proof (illustration?) that functions are hoisted before variables
	foo (); // "foo"

	var foo = 2;
	function (foo)  {
		console.log ("bar");
	}

function foo () {
	console.log("foo")
}

# Declare and Compile ..

function (foo)  {
	console.log ("bar");
}

function foo () {
	console.log("foo")
}
var foo  // Ignored declaration. There is already a var called foo. 
foo (); // "foo"

foo = 2;
# What is point of hoisting in JS? 
# Recursion is when a function calls itelf. 
# Mutual recurion refers to two or more functions calling each other.
# a calls b, b calls a, ..., until some terminating condtion. 
# Turns out mutual recurion is impossible in language without hoisting.
# Because one of functions would always be declared too late.
#
#
console.log(a(1));

function a (foo) {
	if (foo > 20) return foo;
	return b (foo +2)
}

function b (foo) {

	return c(foo) + 1;
}

function c (foo) {

	return a(foo*2);
}

# // 39

# 'Let' Gotcha
function foo(bar) {
	if(bar) {
		console.log(baz); // Reference Error
		let baz = bar;
	}
}

foo("bar");

# JS spec calls this 'temporal dead zone'
# If you try (as above) to reference a variable before it
# has been declared with 'let', it is called referencing 
# in the temporal dead zone. 
# "Lets don't hoist'  But committee say, shouldn't talk of
# hoisting at all.  Talk of referencing in temporal dead  zone.

# Exercise One
# This keyword
# Approximates the dynamic scoping model

# Every function, while executing, has a reference to its current
# execution context, called this.  
# Technically, fibbing a bit. The execution context includes more than
# the 'this' keyword. There is the local variable stack, for example.  
# But for our purposes, all we care about is this binding, so we will
# simplify and say that our execution context is the 'this' keyword. 
# What is meant by execution context?
# How the function is called and when its called. 
# We saw the lexical scoping model was like taking the elevator of building to
# various floors, where the top floor represents the global scope.
# Metaphorically, 'this' is telling us the address of which building 
# to go into. Metaphorically, 'this' is about how to figure out which first
# floor to go into.
# Four  rules for how 'this' keyword gets bound. 
# They all depend on the call site
# The call site is where is code a function gets executed, with its open and
# closed parentheses. 
# Forget about 'self' conceptions, and all comparisons of what 'this' might
# mean in other languages. 
# Nothing to to with OO, instances or classes in JS!
# We need to know the four rules, and their precedence.
# If need to know what 'this' is doing, find call-site and apply the rules
# with due regard for precedence. 
# When the function is called and how its called are the only things that matter.
# Doesn't matter where a function is declared.  The only thing that
# matters is: 'What does the call-site look like?'

function foo() {					# // line1
	console.log(this.bar)   # // line2
}

var bar = "bar11"					# // line 5
var o2 = {bar: "bar2", foo: foo};		# // line 6
var o3 = {bar: "bar3", foo: foo}; 	# // line 7

foo(); // Undefined (node) or bar1  # // line 9
o2.foo(): // bar2										# // line 10
	o3.foo(); // bar3										# // line 11


# Rule 1.  Default Binding Rule
# Fourth in terms of order of preference
# In above example, when we call foo in the 'normal' sense,
# line 9 above.
# The call-site on line 9.  The function stands alone, all by itself
# we can pass parms if we like. Its just a ref to function, and this is 
# nothing else to that function call. 
# When this is what the call site looks like, the default binding rule applies.
# Also true with IIFEs.

# The default rule is as follows:
# If you are in strict mode, default 'this' to undefined 
# If you are not in strict mode, default 'this' to global object
# Not the mode of the entire program but the mode (strict or not) running inside the foo function
#
# Rule 2.  Implicit Binding Rule
# In JS, everything is a ref to a fn  or a var
# On line 6, two different references to the foo function.  The global variable foo
# o2.foo also references it. 
# On line 10, o2.foo(), we make a reference to a function via the object property reference.
# When call site looks like o2.foo, ie when there is an object property reference at the 
# call site, rule 2 (third in order of precedence) kicks in. 

# When there is an object property reference at the call site, that object at the call site
# becomes 'this' (this binding) 

# On line 10, this keyword point to o2. Exact same thing with line 11 (get bar3);

# To further reinforce that it does not matter where a function is declared, let's have
# a look at this example

	var o1 = {
bar: "bar1",
		 foo: function () {
			 console.log(this.bar);
		 }
	};
var o2 = { bar: "bar2", foo: o1.foo};
var bar = "bar3"
var foo = o1.foo;

o1.foo(); // bar1
o2.foo(); // bar2
foo();   // undefined (node) (bar1 in not strict)

# Absolutely no difference in terms of behaviour.  Only thing
# that matters is what the call site looks like. 
# The global object in the browser is the window.
# In node, it is a special global object
# global obj has props that correspond to global variables

# Detour Binding Confusion
function foo () {
	var bar = "bar1"
		baz();
}

function baz () {
	console.log(this.bar);
}

var bar = "bar2"
foo();


# There is no 'cross-bridge' between the lexical scoping 
# mechanism and the 'this' scoping mechanism.
# Apply the rules!! 
# It is impossible to create a crossover between the lexical environment and
# the 'this' binding mechanism.  Two fundamentally different mechanisms.

# Rule 3 Explicit Binding

# Second in order of precedence
# If you have a .call or a .apply at the call site, both of these utilities
# take as their first parameter a 'this' binding (called a 'this-arg');
# Call and apply DO have different behaviours in terms of arguments, but
# have identical behaviour in terms of 'this'. 
# when say
foo()
# this is a plain default binding rule
# When I say
	foo.call(obj);
#it says 'use obj as my this' 
# We are explicitly stating with this binding we want to apply. 
	function  foo () {
		console.log(this.bar)
	}

var bar = "bar1"
var obj = {bar: "bar2"};
foo();
foo.call(obj);
# Detour
# This binding is very flexible. Can mean different things at
# different times.  
# Sometimes want 'this' behaviour to be entirely predictable.
# Hard binding is the soln. Is there a way to take a fn
# and 'hard bind' the 'this' keyword so that it is a predictable
# object

function foo () {
	console.log(this.bar)
}
var obj = {bar: "bar"}
var obj2 = {bar: "bar2"}

var orig = foo;  #  //line 8
foo = function () { orig.call(obj); };

foo();  #// bar   
foo.call(obj2);  #//bar (!)

# Lines 1-3 have a foo function as previous
# But look at line 8
# Make another reference to the same function. 
# called 'orig'.  So it is a reference to the original
# function. Now I overwrite the 'foo' ( I don't HAVE to
# overwrite it) with a whole new function, in this case a 
# function expression. 
# What is new function coded to do? Look at line 9.
# Whenever foo is called from now on, he will always
# call  the original function, but he will force the 'this' reference
# to always be 'obj'
# No matter how foo is called 'orig' will always be called with
# the obj binding
# So line ll (foo()) gives bar as expected
# but also
# line 12 foo.call(obj2);, will give bar.
# That is, when we try to overwrite we still get 'bar', and here's why
# foo.call() on line12 says 'I want you to use obj2'. The 'this' binding
# of the wrapper is ignored. This is what is called 'hard binding'
# Very usefule in Ajax calls and asynchronous coding. 
# This has reduced flexibility, but is entirely predictable.
# Still a but 'clunky''
# #whan we create a utility to do this?
# yes
# First step make a function called bind that
# accepts two parameters.  A function parameter and the object you 
# want to bind for 'this'. 
# The utility creates a whole new function that is hard coded to 
# call 'fn' with 'o' as his 'this', as seen on line 3 below.  
# Same thing as the previous code, but have now created a reusable
# utility that does not have a variable hanging out in the global
# space. 
# We use it in exact way you would expect.  On line 13
# foo = bind(foo, obj);
# Now when call foo all by himself on line 15, he still references
# obj as bar. Not falling back to global.
# Line 15 is not the call site anymore.  This is an important nuance.
# The call site is actually on line 3. Subtle nuance, but super-important
# detail. When you are finding the call site, if there is a hard-bound
# wrapper, that is not the call site anymore. You have to go inside
# wrapper to find call site. 
function bind(fn, o) {
	return function () {
		fn.call(o);   # // line 3
	};
	function foo() {
		console.log(this.bar);
	}

	var obj = {bar: "bar"};
	var obj2 = {bar: "bar2"};

	foo = bind(foo, obj);

	foo();  # // Line 15
		foo.call(obj2);

#  The function calls on lines 15 and 16 
#  both give bar. 

# Hard binding is nice, but still a bit clunky in that we have had
# to create a global utility called 'bind'
# CAN put this utility on function prototype. 
# Temporarily for the purpose of this slide only will call function
# bind2.

	if (!Function.prototype.bind2) {
		Function.prototype.bind2 = function(o) {
			var fn = this; // the function
			return function () {
				return fn.apply(o, arguments);
			};
		};
	}
	function foo(baz) {
		console.log(this.bar + " " + baz);
	}
	var obj = {bar: "bar"};
	foo = foo.bind2(obj);
	foo("baz");
# // returns bar baz

# bind is already built into javascript as of ES5. 
#MDN website provides a polyfill function that allows
# you to use Function.prototype.bind in pre-ES5 browsers.
# that's what polyfills are for. 
# Use the one from MDN.  It is better than one Kyle derived.

# The New Keyword
#The fourth of our rulles. 
#Set aside any preconceptions from the world of OO.
#Nothing to do with instiating classes.
#For a start JS does ot have classes
#Secondly, the New keyword has nothing to do with instantiating
#classes, whatever you may have been told.

# What does the new keyword do in JS?
# When you put the New keyword in front of any function it 
# magically turns that function into what might be called a 
# constructor call. 

	function foo() {
		this.baz = "baz";
		console.log(this.bar + " " + baz);  #// line 3
	}    # // line 4
	var bar  = "bar";
	var baz = new foo();
	console.log(baz.baz);
	console.log(baz);

# // undefined undefined
# // baz
# // { baz: 'baz' }

# When we put 'new' keyword in front of function  call, it is going to do
# four things
#1.  A brand new object is created 'out of thin air'
#2.  We need to askerisk this one.  Will explain in more detail later
#    Will tell what is, but is not goint to make sense
#    Will come back later and fix explanation
#    The second thing that happens to our 'poof out of thin air new object' is that
#    it gets linked to a new object. Linkage will be explained later.
#3.  That brand new 'poof' object gets bound as  the 'this' keyword for the purposes of
#    the function call. 
#4	 The fourth thing that occurs when the 'new' keyword
#    is put in front of a function call is that
#    If that  function does not otherwise return anything then 
#    it will implicitly insert (between lines 3 and 4 in above eg) 
#    a 'return this'

# So that brand new 'poof' object will be implicitly returned for us. 
# What this means it that you can take any function, don't care what the
# function does, and you have hijacked that function call as a constructor
# call.  It will also do all the stuff it is supposed to do, but in addition it   # will also do the above four things. 
# So its the 'site channel'. Create an object, link him, implicitly bind him and  # send him back to me.  

# So in example above: 'new foo() creates a new object out of thin
# air. And will be assigned to 'this'. So can say on 
# line two 'this.baz' is "baz".
# When ask for 'this.bar', there IS NO 'this.bar', so will be
# undefined (yes!), AND at the moment, the baz variable
# exists BUT HAS NO VALUE, so will get undefined again
	undefined undefined
# (That's what was obtained in node). 
# But the final thing that occurs.  There is an implicit 'return
# this', so that our newly created object gets assigned to our
# baz variable (!! Yes).  So now if 
# console.log(baz.baz) get "baz".
#
# So .. the fourth and final way that a 'this' keyword gets bound
# is that it can be bound to a brand new object that it was 
# created as part of a constructor call hijacking. 
#
# Order of Precedence of Four Rules
# Call site could conceivable conform to more than one rule.
# Here are the questions to ask.

#1. Was the function called with 'new'? 
#   If so, use that object.
#   This means that the 'new' keyword can overwrite all other rules.

#2  Was the function called with 'call' or 'apply'.  
#   If so use that object. (Explicit binding)
#3. Was the function called via  containing/owming object (context)?
#   If so, use that object
#4  Default to global object, except in strict mode where default
#   to undefined.  

#  So ... An example of a surprising result.  Hard bound functions
#  are a variation on the explicit binding rule. In order of 
#  precedence, this falls at number 2. So the new keyword is even 
#  able to over-ride hardbinding. 
#
#  Quiz
# How do you "borrow" a function by implicit assignment of 'this'?
# When you call the function it was in the context of an object.
# We mutated an object to put a reference to that function
# on the object so that we can say 'object.methodName' 

# How do you explicitly bind 'this'?
# call and apply. 

# How do you seal a specific 'this' to a function? Why do that?
# Why not?
# Use the '.bind' utility. Create a hard-bound reference.
# Advantage: predictability. 
# Disadvantage: loss of flexibility.

# How do you create a 'new' this object? 
# By using the 'new' keyword. 
#
# To reinforce.  The 'this' mechanism is dynamic. It is a 
# binding mechanism that looks for things at run-time. 
# Entirely based upon how you call something. Could have
# the same function called in four different ways and get
# four entirely different bindings.
# Contrast with lexical scoping which is hard-coded at author time.


# New Module: Closure

# Clousures.  Just like when Neo seeds the matrix!
# Closure comes from lambda calculus
# Kyle' definition.

# Closure is when a function "remembers" its lexical scope
# even when the function is executed outside that lexical
# scope. 

		function foo () {  #// line 1
			var bar = "baz";

			function baz() {   # // line 4
				console.log(bar);
			}

			bam(baz);
		}

	function bam(baz) {   #// line 11
		baz() 
	}

	foo();

# We know have a scope bubble around baz which is
# inside the scope bubble around foo.
# We know that baz can reference bar. 
# It first checks for local var on  line 4.5, does not find
# so 'goes up a level'.  Finds it in the enclosing scope
# on line-2.  That mechanism is most appropiately
# described as lexical scope. 
# But because JS has first-class functions, functions
# can be passed around and can be executing in 
# entirely different environments. 
# So if we take a ref to the function baz and pass it
# outside of (tgd: to?)   the function foo.  
# In other words, on line 8 I take a ref to baz and
# pass to another function.
# On line 12 when I execute baz, he is still able to
# access the lexical scope in which he was defined even 
# though he is executing outside of that lexical scope.
#
# Executing outside of the bubble. 
# There is a scope buffle from lines 1 -9, but he is
# executing outside that bubble. But still has access to 
# th bar variable!  That is closure.  
# The fact that the lexical scope stayed attached to the
# function no matter where he got transported. 

# Some more examples.  You can also return functions
# from functions.  And pass them as parameters.

	function foo() {
		var bar = "bar";

		return function() { #// line 4
			console.log(bar);
		}
	}

	function bam() {     # // line 9
		foo()();
	}

	bam();


#On line 10 first call to foo 'gets' the inner function  -ie
#the inner function is returned - and then the second set
#calls this function. 

# In the microsecond betweent the first set of parens and the second
# set, that function has been transported outside its lexical
# scope, and he is still able to access the lexical scope.  That is
# closure. 

# Another example

function foo () {
var bar = "bar";

setTimeout(function() {
console.log(bar);
},1000);

}

foo();

# Works as expected. 
# One second delay, then prints 'bar'.
# That's because of closure
#
# setTimeout receives a callback to execute your function.
# When you pass a function into a setTimeOut, or any callback,
# and that function is able to remember the variable.
# Inside the engine somewhere there is a 'setTimeOut' utility
# and he gets a little callback called  'cb' which will execute
# at some point.  He will execute your function well outside of
# its lexical scope.  But your function still remembers is 
# lexical scope because of closure. 
# Audience Question.  What would happen if the var bar
# were to change its value in the time between function 
# call and setTimeOut call?
# Kyle: That's exactly what I meant by saying it is NOT like
# a snapshot. Its like a live link. The new value is what would
# be taken. It would access the current value at that moment. 
#

# Another example from click-handlers.
# If you are familiar with any kinds of frameworks that do
# click-handlers. Click-handlers are able to remember something
# about their lexical environment. 
# That's entirely because of closure.
# Closure is a necessary mechanism for a language with first-class
# functions as values to be useful. 
# If functions could be passed around with their values but 
# could not remember anything about lexical scope, no-one would
# pass around functions. The only reason we find this useful is
# that they implicitly have this capability called closure.
# 
function foo() {

var bar = "bar";

$("#btn").click(function(evt) {

console.log(bar);
});
}

foo(); 

# Another example.

function foo () {
var bar =0;

setTimeOut(function () {
console.log(bar++);
}, 1000);
setTimeOut(function() {
console.log(bar++);
},200);
}

foo();

# The above is an important one
# Both setTimeout functions have closure over the same scope
# Another way to process the concept of closure.
# You are probably familiar with the concept of garbage collection in JS.
# If  you keep a reference to an object, that obj does not get garbage collected.
# If 10 refs to an obj, get rid of nine, still not GC.  Get rid of 10th, and now
# the engine can garbage collect.
# The same similar type of mechanism is at work with scope. 
# When you execute a function is creates a scope object. If anything (anybody) 
# gets a reference to that scope object via closure, that scope does not
# get GC when the function ends. It keeps the scope around, and it can continue 
# to keep modifying it and accessing it, as long as there is at least one function
# with a closure over the scope, that scope does not go away. 

# Another good example.

function foo () {
	var bar = 0;

	setTimeout(function() {
			var baz = 1;
			console.log(bar++);

			setTimeout(function() {
				console.log(bar + baz);
				},2000);
			},1000);
}

foo ();

# // 0
# // 2

# Canonical idea for showing how closure works.

function foo () {

	for (var i =0; i <=5; i++) {
		setTimeout( function () {
			console.log("i " + i )
		},5000);
	} 
}

foo();

# // Waits 5 seconds, the prints (instaneously) "i 6" FIVE TIMES

# Why 6? Well, i at the end of the loop will be '6'
# Obviously, 'i' is already 6 before these functions are running.
# Whyd don't we have five different 'i's 
# Our developer brains seem to think that we are getting
# a whole new i for each iteration of the loop.  
# But they are not, are they?
# They are five different functions that are closing over
# the exact same global scope.
# No different that writing the setTimeouts  five times on
# top of each other, like did on previous slide.

# This if five separate anonymous functions that close
# over the exact same scope. 
# So, what's missing?  What can I do to this piece of 
# code that would allow it to have a different i for each
# iteration of the loop.  To have a whole different scope
# for each iteration. 
#
# That solution is typically the IIFE


function foo () {
	for(var i=0; i<=5; i++) { 
		(function(i){
		 setTimeout(function () {
			 console.log("i " + i); 
			 }, i*2000)
		 })(i);
	}
}

foo();

# Remember, functions are the unit of scope in JS. 
# each function is now closing over an iteration scope, 
# rather than over the global scope.  

# The canonical solution is to put an iife inside a loop.
# bacause what was really missing is that we wanted a scope
# for each iteration.  

# Another solution is to use the 'let' keyword
"use strict"
function foo () {

	for (let i = 0; i <=5; i++) {i
		setTimeout( function () {
			console.log("i " + i )
		},5000);
	} 
}

foo();

# Note from tgd. Would not work in node - threw error
# Did not work in firbug conole (got '6' five times)
# Should, according to Kyle, not only bind 'i' to the
# 'for' loop, but should rebind 'i' for each iteration
# of the loop.  Should work without using iife.  
#
# Is this a closure?

var foo = (function () {

		var o = {bar: "bar"};
		return {obj: o};
		})();

console.log(foo.obj.bar);  # // "bar"

# No, not closure. 
# This IS an iife
# Go back to closure definition.  When a function remembers its
# lexical scope even when the function is executing outside
# the lexical scope. 

# There is no function remembering its lexical scope.  We didn't 
# transport a function out.  There is no inner function that
# is being transported out.  We ARE keeping an object ref
# around - the code works, but we are not having a function
# keep a reference to a scope. 

																# Module Pattern
#Let's talk about some practical uses for closure.
# Remember how we talked about IIFE being one of the most
# common pattern.  If not the first-most, then the second-most.
# What we are about to see here is the first-most.

									# Classic Module Pattern (Douglas Crockford)

var foo = (function () {
		var o = {bar:  "bar"}
		return {
bar: function () {
console.log(o.bar);
		}
	} 
})();

foo.bar(); 

# The 'classic' JS module pattern, as implemented by
# Douglas Crockford, has two defining characteristics.

#1  There must be an outer wrapping function that gets executed.
#   It does NOT have to  be an iife
#   In the above case it is an iife

#2 The second characteristics is that there must be one
# or more inner functions that have closure over the inner
# private scope.  The inner function will get 'returned out'
# and keeps a closure over the internal state. 

#The idea is encapsulation. 
# comes from the principle  of least priviledge or the 
# principle of least exposure.  Make everything private and 
# only expose everything that needs to be public. 
# Not a class!! 
# CAN Return the function without the object. That is still
# a module.  That is exactly what jQuery does.  
#  Stopped at 1.39 of module 
													 
													 # Modified Module Pattern 

var foo = (function () {
		var publicAPI = {
			bar: function () {
				publicAPI.baz();
			}, 
		baz: function () {
				console.log("baz");
		}
	};
	return publicAPI;
})();

foo.bar():

# Kyle likes to give a name to the (otherwise)
# anonymous object. 
# Rather than returning back an anonymous object, Kyle likes
# to call it publicAPI. 
# stylistically, helps keep track of public vs private
# functionally, if give a name, can modify at runtime, by
# updating a property.  
#
# Both foo and publicAPI are references to the same object.

														# Modern Module Pattern 

define("foo", function () {

	var o = {bar: "baz"};
		return {
			bar: function() {
				console.log(o.bar);
			}
		};

});

# Modern module pattern is something you are probably already
# familiar with if you are using 'require' or one of those.
# Kyle has just made one up.  Called it define. 
# Any relationship to existing loaders is entirely coincidental
# Takes a name for my module, and takes a function that returns
# back an object. 
# Same characteristics of module pattern but do not see
# execution of that function that takes that value and assigns it 
# to a name.  That is the part that the library is doing for you. 
# But it is still the module pattern. 
# In his 'Scope and Closures' book there is an example 

												 #Future of ES6 Module Pattern

# As of ES6, we have first-class support for modules. 
# It is file-based. Both a plus and a minus
# Basically going to treat the contents of a file as if it 
# conceptually exists inside of a function.  We don't have
# to write the function, but it will have its own scope.

# Insead of returning things, use new keyword called 'export'
# Everything you export will get added to public API for 
# the module.  Can call export once or a hundred times. 
#
foo.js

var o = {bar : "bar"}

	export function bar() {
		return o.bar;
}

# It is way the file gets loaded that is now important.
# There are TWO keywords for importing.

import bar from "foo";
bar();

module foo from "foo";

foo.bar(); // bar

# import bar from "foo" just pulls in the 'bar', not the whole
# module. 
# If I want the whole module, use module keyword.  

# 'module' keyword is still in a state of flux as of ES6 and
# must come with a caveat. May be rejected.  
# Remember, just syntatic sugar.  

																		 # Quiz 
#1 What is a closure and how is it created?
# A closure is function that keeps its lexical scope when it is 
# called somewhere else
# A closure is when a function remembers and accesses its lexical
# scope even when that function is called outside that lexical scope.
#
# How is it created? When an inner function is 'transported' 
# outside of the outer function. 
#
#2 How long does its scope stay around? 
# For as long as there is a function with a closure over the scope. 

#3 Why doesn't a function callback inside a loop behave as expected?
# How do we fix it?
# There was not a var i created per iteration.
# Solve with IIFE, or use 'let' keyword.
#
#4 How do you use a closure to create an encapsulated module? What
# are the benefits of this approach?
# Has to be an outer wrapper function
# Return one of more inner functions with closure over scope.
# Benefit is hiding. Principle of least exposure.
# Trade-offs.  Some say makes inner stuff harder to test. Kyle does
# not necessarily agree. 
# Another trade-off.  Every time I create a new module, If have 1000 
# modules, have 1000 versions of individual functionality.  
#
																 # Exercise Two
# Exercise two completed.  Two verions - IIFE and non-IIFE.

# New Module
															 # Object Orienting
# Kyle's take in this module a bit different from what normally accepted.

# Prototype mechanism. 

# Every single "object" is built by a constructor function. 
# More accurate to say built by constructor call. 

# We have already been shown this. When we call 'new' with a function it creates an object.  This is NOT the same thing as instantiating a class.
# It just constructs objects.

# As a matter of fact, Kyle would push back on 2-3 decades of 
# precedence, and say that referring to languages such as C++
# and Java as 'Object - Oriented' is a bit of a misnomer.  They
# should have been called 'Class - Oriented'.  In fact, only two
# languages today that are properly called object-orientated.
# JavaScript and Lua. In these languages can create an object
# without a class. 

# It is often said that a constuctor makes an object 
# "based on" its own prototype. 

# Kyle does not like the above definition. He objects to the
# phrase "based on".  It implies something about the language
# that is not true. True in other OO languaages such as C++
# Java. 
# "Based on" implies that we take the prototype and we
# stamp out a copy of it.  That's the way it works in 
# class-oriented languages. When you have a parent class
# and you instantiate a parent class, there is a copy of the
# behaviour of the class into the instance, and once the 
# two have been separated there is no more relationship between
# the two. I have an instance that was a copy of a parent. 

# That  is not what happens in JavaScript. The phrase 'based on'
# really leads us down the wrong path. 

# It is more appropiate to say that  a constructor makes an object
# that is LINKED TO its own prototype.  
# oWhen we discussed the 'new' keyword, we discussed the four steps.
#
# and I told you point 2 was that it linked to an object.  Kyle
# said 'put an asterisk' beside no 2: we will discuss later'
# We are now going to discuss that linkage. 
# Next Prototype explained... 

function Foo (who) {    # // Line One
	this.me = who;   # // Line Two
}
Foo.prototype.identity = function() {  # // Line Four
	return "I am " + this.me;
};

var a1 = new Foo("a1");  # // Line 8
var a2 = new Foo("a2");

a2.speak = function () { # // Line 11
	alert("Hello, ",  + this.identity() + ".");
};

a1.constructor === Foo;   # // Line 15. 
a1.constructor === a2.constuctor;
a1.__proto__ === Foo.prototype; #  // Line 17
a1.__proto__ === a2.__proto__;


# Kyle is going to draw a diagram showing what occurs when the above
# code is interpreted by the JS engine.  
# The diagram is in pdf format in the exercise files ('day1')
# Everything above dotted line indicates stuff that has already
# happened before we get to line 1. 
# I will represent objects as squares, and functions as circles
# Above the dotted line  there is a FUNCTION called object
# AND there is an object (of no particular name) to which the 
# function is linked. The object does not have a name, but has
# a (wierd?) name called 'object.prototype'.
# Methods on the object include
# toString()
# valueOf()
# hasOwnProperty()
# isPrototypeOf()
# and other things we may be familiar with built into the object. 
# All come from the object. 
#
function Foo (who) {    # // Line One

# What does line one do for us?
# Creates a circle that we give the label 'Foo'. 
# Also creates an object -Will have same arbitrary name called .prototype.
# In addition, the object has a property on him called '.constructor'
# NOTE '.constructor' does NOT MEAN 'was constructed by'.  In other words
# the new object was constructed by the new function.  Not true.  The
# word constructor is just an arbitrary word.  It could just have easily
# been 'abracadabra'. But note the dual linkage.  .prototype point to
# the object from the function, and .constructor points to the function
# from the object. 

# Let's now turn to line four. 
Foo.prototype.identity = function() {  # // Line Four

# We start adding properties to Foo.prototype (ie the 'square' or 
# object of line 1).  identify() added to object box. 

var a1 = new Foo("a1");  # // Line 8

# Lets turn to line 8.  What are the four things that happen when
# the 'new' keyword is invoked?
#1  A brand new object is created.
#   (Draw a square) 
#2  Object get linked to Object 
#   Draw square-to-square linkage from new object to Foo.prototype.
#3  The context gets set to 'this'
#   When we are calling the Foo function, the 'this' keyword will be 
#   pointing at this particular object.  
#   When we execute line 2 and say 'this.me', 'this' refers to the
#   new object created out of thin air by the 'new' keyword.
#   We are putting a property directly on this object

	this.me = who;   # // Line Two
#  Add 'me' to the object square.
#  #4 The fourth thing that happens it that it returns 'this.  So we give
#  a label to the object, 'a1'. 
#  Notice that we haven't talked about classes or inheritance or
#  instantiation, or anything like that. 
#
#line 9.  Does the exact same thing as line eight.  Another box created

# Now lets look at line 11
a2.speak = function () { # // Line 11
# gets added to the a2 object.  (a2 square gets that property). 
# Not added to a1

# Now lets look at line 15

a1.constructor === Foo;   # // Line 15. 

# There is no constructor property on a1. 
# Better than 99% of all JavaScript developers think there is a hidden
# constructor property. So when we say 'a1.constuctor', and it doesnt exist
# what happens?  It goes up the prototype chain. 
# This is where the prototype mechanism begins to look a lot like a scope model.
# The linkages that Kyle talked about are called the prototype link.
# In 'spec-speak', prototype is referenced by [[Prototype]] 
# Can see right away why that is confusing, because they call the
# other one '.prototype'. 
# the linkage between the a1 object and the 'parent' Foo object are
# [[Prototype]] linkages. These are internal linkages, not available
# publically. They are just an internal link between the two. Forms 
# a prototype chain we can traverse. 
#
# By the way, let's pause here for a second...
# Something needs to be added. 
# Remember line1.  Well, we forgot something.  The internal linkage
# betweent the objects. 
#
# So... now lets go back to line 15.
# When we call a1.construtor, delegates to 'parent' foo object WHICH
# DOES have a constructor, and he ends up being Foo!  Very nice

# At this point you would be forgiven if you were under this misconception
# that a1.constructor pointing at Foo means that 'Foo was the one
# that constructed me'. That is a misconception. '.constructor' does not
# mean 'I was constructed by', it just happens as a happy accident to
# point to the location we would want it to.  We shall see in a few
# slides how that assumption goes completly away in other circumstances. 
# a2.constructor will also point to foo
													# Prototype Examples Part 2

# Now what about Line 17?

a1.__proto__ === Foo.prototype; #  // Line 17

# We start referencing this bizarrely name property '__proto__'.
# Lets have an aside.  A couple of years ago, the JS community
# was trying to come up with a better name for that, because no-one
# wants to underscore-underscore-proto-underscore-underscore. 
# Came up with 'dunder'. So properly 'dunder-proto'. 
# Is there a dunder-proto on a1? No
# Is there a dunder-proto on parent object? No
# So up to object wihin dotted line, the one created in every JS environment
# It turns out that there is a dunder-proto on the built-in object.prototype.
# Not actually a property.  It is in fact a getter function. 
# A bit like making a function call on line 17.  Guess what that function
# call does?  It returns the internal prototype linkage of whatever the
# 'this' binding is. 
# At the call site on line 17, we pretend that there is some parentheses 
# there on line 17. When we are calling a function what will the 'this'
# keyword be inside that function call?  a1. So it is going to
# return the internal prototype linkage of a1. [[Prototype]] is the internal
# link.  We can say that the public link is dunder-proto or __proto__ .
# It is a public property that references an internal characteristic. 
# The problem with dunder-proto is that it has never been standardized. 
# It was invented 15 years ago by Mozilla because they wanted some way
# to public expose that internal property. But even though not 
# standardized, everyone adopted it. Safari, Chrome but NOT IE! In a 
# shocking twist of irony, IE - the king of non-standard add-ins - decided
# not to add something that is not standard, but everyone else did. 
# Could never agree on TC-39 committee how to standardize.  So became
# a de-facto standard except for IE. 
# But is IS standardized in ES6.  IE dropped into IE11.  
# Next slide (see pdf), same function but different from line 15 on

a1.__proto__ === Object.getPrototypeOf(a1)
a2.constructor === Foo;
a1.__proto__ == a2.__proto__;
a2.__proto__ == a2.constructor.prototype; # // Line 18.  

# Same code but Kyle wants to illustrate one other thing.
# As dunder-proto was not standard until ES6, back in the
# ES5 days (2009 -2011) the commitee was aware that 
# a standard way of accessing the internal prototype 
# characteristic was necessary. We are not going to do it with
# dunder-proto, but will need to provide some way of doing it. 
# They added Object.getProtoytypeOf(a1); Gives us the [[Prototype]]
# linkage of a1. So whereas you didnt' have dunder-prototype, you
# did have Object.getPrototypeOf(), as of IE9. Which is a lot 
# better than IE11, but it still leaves IE8 and below  out in the cold. 
# What do we do about IE8 and below?
# We now come to the third way, a 'crappy hacky' way that we
# can get at that linkage. Way we do that is what we see on line 18
# We can say
a2.constructor.prototype
#This 'closed loop' will also get us to the object.
# Now, here's the problem.  Both the constructor property and
# the prototype property are WRITEABLE. They happen to default to
# pointing to where we show them, but guess what happens if either
# or both get over-written. Then this third way of doing things is
# completely out the window. Totally non-reliable.  They are just
# properties that can be changed.
#
# Executed in the console (using node.js)

console.log(a1.constructor);               
# //[Function: Foo]

console.log(a1.__proto__);               
# //{ identity: [Function] }

console.log(Foo.prototype);              
# //{ identity: [Function] }

console.log(a2.__proto__);               
# // { identity: [Function] }

console.log('------');                   
console.log(Object.getPrototypeOf(a1));  
#  //{ identity: [Function] }
console.log(a2.constructor);             
# // [Function: Foo]
console.log(a2.constructor.prototype);
#  // { identity: [Function] }

# Some important identities. 
a1.constructor === Foo;
a1.constructor === a2.constuctor;
a1.__proto__ === Foo.prototype;
a1.__proto__ === a2.__proto__;
a1.__proto__ === Object.getPrototypeOf(a1)
a2.constructor === Foo;
a1.__proto__ == a2.__proto__;
a2.__proto__ == a2.constructor.prototype;

# But these are the three ways of getting the object-to-object linkage
#1 dunder prototype
#2 Object.getPrototypeOf()
#3 a2.constructor.prototype.  (The crappy ES3 way of doing things) 
														# The Prototype linkage
# So what about this linkage we have been talking about?
# What happens if I call a1.identify?  What is it going to do?
# No identify on a1, so it goes up the chain to the next object, which does!
# So here we see the first benefit of the prototype linkage.  We have 
# the ability to delegate to another object to handle a method call or
# property reference. Notice that a1 and a2 can both delegate,and there
# is not multiple copies of identify as there would be in the module pattern. 
# What happens if we create 1000 of these? a1 -a1000. If all linked to
# same object, there will still only be one copy of the function. 
# And that function we see there on line 5 

Foo.prototype.identity = function() {  # // Line Four
	return "I am " + this.me;
};

# When I say a1.identify, what is 'this binding going to be? a1, which is what
# we want it to be. So it will get the me that a1 has. 

#If we say a2.identify, then this binding will be to a2. 
# So the 'this' keyword ends up being a very nice mechanism for us
# when we are dealing with the prototype chain (but only when we
# behave by the rules!)

# Slightly different code ...

function Foo(who) {
	this.me = who;
}
Foo.prototype.identify = function () {
	return "I am " + this.me;
};
var a1 = new Foo("a1");
console.log(a1.identify()); 
a1.identify = function () { # // Line 11.  Shadowing
	console.log("Hello, " +
	Foo.prototype.identify.call(this) +  # // Line 13 
	".");
};
a1.identify();  # // Line 17 

# // I am a1
# // Hello, I am a1 

# So what happens if on line 11 I say 'a1.identify' and I add a property.  What does it
# change?  it adds to property to a1. 
# So now when we call a1.idenftify on line 17, we are calling the new property. This
# is called shadowing.  There are two different properties on the prototype chain
# with the same property. 

# This is where things begin to break down. In class-oriented coding, the design pattern of
# classes tell you to create parent classes and child classes that have methods of the same
# name, and allows relative polymorphism where 'super' calls one level up the chain. That is
# one of the advantages of classes.  You can use the same name for methods at different
# levels.
# But in JS, we see (Line 13) how it creates a whole world of problems. Look how I 
# have to reference the original identify. 
# Kyle calls this 'explicit polymorphism'. 
Foo.prototype.identify.call(this)
#Shadowing. same method name in multiple levels of the prototype chain. 
# If, however, had called new property 'identify2', or anything else other than 'identify'
# delegation would have worked beautifully.  
# If use different method names, everything works beautifully.  
# This shows what Kyle calls 'super-unicorn magic'.

function Foo(who) {
	this.me = who;
}

Foo.prototype.identify = function () {
	return "I am " + this.me;
};

Foo.prototype.speak = function () {
	console.log ("Hello " +
			this.identify () +  #// super unicorn magic
			".");
};

var a1 = new Foo("a1");
a1.speak();  

# On line 16, when I call 'a1.speak()' 
# speak gets called through delegation
# but what does speak do?  He says 'this.identify'
# and what is 'this'? Well, a1... 
# We might as well have said a1.identify.
# Does a1 have an identify? No ... 
# So he steps right back up the prototype chain.  
# So through delegation identify gets called! 
# Very nice. The nice thing about the mechanism is that it is always rooted
# at the call site. 
# The 'this' keyword always references the call site. And this is almost always
# what we want, unless we do that crappy shadowing thing. 
# Avoid shaowing for 'super-unicorn' magic. 
# Audience question response. We have spend the best part of 19 years since
# JS was invented trying to pretend that JS has classes. 
# It all boils down to that the above are NOT copy mechanisms, but
# prototype linkage behaviour delegation mechanisms.
# So finally back to the 'building/elevator' diagram. 
# We have addressed lexical scoping on the RHS. We now know what 'this' plus
# prototype tells us about the RHS building. The 'this' keyword tells us
# which building to go into. The prototype mechanism tells us how to find
# properties if they do not exist on the direct object. When we say 'a1.identify, it
# first looks on the first floor of a1, if it does not find it there, it goes up
# one level. Keeps going until it gets to object.prototype. The analog of the global
# scope. Remember that although the lexical scoping and prototype mechanisms are
# similar in that they both have elevators, they do not cross over in any shape
# or form. They are two orthagonal mechanisms. 

															# Prototype: Objects
# Here's why things get complicated with respect to '.constructor' and when we
# start trying to model things as classes.  We have a function 'Foo' that is representing
# a class, that is why has capital letter. We start adding thing like 'identify' to its
# prototype and then I want to create a child 'class' called 'Bar' that is supposed
# to extend or inherit from the parent 'class' Foo. 

function Foo (who) {
	this.me = who;
}

Foo.prototype.identify = function () {
	return "I am " + this.me;
};

function Bar(who) {
	Foo.call(this, who);
}
//Bar.prototype = new Foo();
Bar.prototype = Object.create(Foo.prototype); # // Line 12
//Note .constructor is borked here.  Need to fix.

Bar.prototype.speak = function () {
	console.log("Hello, " + this.identify() + ".");
};

var b1 = new Bar("b1");
var b2 = new Nar("b2");

b1.speak();
b2.speak();
//Hello, I am b1.
//Hello, I am b2.

# MDN Aside
#InstanceOf
The instanceof operator tests whether an object has in its prototype chain the prototype property of a constructor.
# The 'instanceof operator tests whether an objece has in its prototype
# chain the prototype property of a constructor
#Syntax
object instanceof constructor
# Object.create()
# The Object.create() method creates a new object with the
# specified prototype object and properties.
#-------------
# Line 12 shows how you might accomplish that.  Links the prototype of Bar to that of Foo
# COULD do as shown in commented line 11. That would work very nicely but would have the
# undesired side-effect of calling Foo, and adding properties like this.me which we do not want.
# So we cannot really call the constructor. 
# The other way we can do it is to use Object.create. This was standardized as of ES5. 
# Object.create essentially does the first two of the four steps that the 'new' keyword does.
# What are those two steps?
#1 Creates a new object
#2 Links it 

# Does not do steps 3 and 4. 
# So Object.create is a nice useful helper for us that will create 
# Bar.prototype that is linked to Foo.prototype.
# We can add things like Bar.prototype.speak 
# When we say var b1 = new Bar(), and then say b1.speak(),
# it delegates from b1 up to Bar.prototype where it finds a speak function
# where it will see this.identify, and 'this' will refer to 'b1'. 
# Is there a b1.identify?
# No, so delegate to Bar.prototype. Is there a Bar.prototype identify?
# Is there a Foo.prototype identify?  Yes. So we execute. He has a 'this' 
# reference. What is he going to be?  b1, still. Super-unicorn magic. So very
# powerful mechanism. But subtle problems arise when you try to think 
# about what is happening in terms of parent/child classes. 
# What would happen if we call b1.constructor?
# What SHOULD it point to? We would like it to be the Bar function. 
# If '.constructor' meant 'was constructed by' we would expect 
# it to point to the Bar function.
# Let's analyze it.
# Does b1 have a constructor? No
# Does Bar.prototype have a constructor?
# NO. Not anymore. The default function on line 8 DID have a constructor
# property, but we threw that one away so that we could link him to Foo.prototype. So the new Bar.prototype that we created through Object.create
# does not have a constructor property.  We delegate up to Foo.prototype.
# Does Foo.prototype have a constructor? Yes. Points to Foo! 
# So we get the really bizarre behaviour that b1.constuctor is Foo. 
# That's weird. But '.constuctor' does NOT mean 'was constructed by',
# but is just an arbitrary property that exists or does not exist. 
# Could solve this problem by adding a constructor to the Bar prototype
# on line 13, and point it manually at bar. But this if very difficult
# Must be non-enumerable. This is one of the problems with JS, and is
# one of the reasons no-one writes this code anymore. They just use
# user libraries to fix all of these problems.

# Kyle is driving towards a method that gets rid of this complexity
# without having to use libraries. 
# So here is the linkage.
# b1 is [[Prototype]] linked to Bar.prototype.
# Bar.prototype is [[Prototype]] linked to Foo.prototype. 

# Linked Prototype Diagram
# Note that dotted lines are IMPLIED relationships
# Actually this diagram a bit of a fib.  There is a lot more going on.
# See next diagram. 
# But there is an internal consistency.
# For example, remember when we talked about function prototype bind, and magically
# Foo could call foo.bind?  You may have wondered 'How is that possible?'
# Well functions are objects, which mean that functions have an internal prototype linkage, so
# they delegate up to the Function.prototype, and thats where they get .call and .apply. 
# When it all boils down, the circles and arrows not that important.  What is important is the squares.
# That is where all the action happens. All the rest is a whole bunch of distraction just to get there.
# Wouldn't it be nice to just make the squares? Thats where we are heading. 
# Quiz Prototype behaviour
# 
#1 What is a constructor? 
# It is a function that is called with the 'new' keyword in front of it
# '.constructor' is a property.

#2  What is [[Prototype]] and where does it come from?
# [[Prototype]] is a linkage from one object to another object
# Where does it come from?  Two ways. Object.create
# Or indirectly as step two of the four steps of the 'new' keyword. 
# Either way, one object linked to another object. 

#3  How does [[Prototype]] affect how we deal with an object?
# We can call a property or a  method on an object, and if the object cannot handle that
# method or property, it delegates up the prototype chain to a different object. 
# Amazingly powerful mechanism. Have NOT described copying! 

# How do we find where an object's [[Prototype]] points to (3 ways)?

#a Dunder-proto
#b Object.getPrototypeOf
#c (crappy-hacky) .constructor.prototype 

# Exercise 3. 
# Kyle prefers the prototype mechanism above the module pattern, 
# neither are his favourite pattern (which is still to come).

# Inheritance
# In classical inheritance, we have a parent class, let's say Foo. 
# When we instantiate Foo, that is when we create an a1 instance of
# Foo, there is a COPY of behaviour from the parent class into the 
# child class. Ditto when create a2 instance. When we create a child
# class called Bar, we are copying behaviour from foo to Bar, and then
# down to b1, b2 etc. Class represents the blueprint.  The builder builds.
# Once the building is built, there is no more relationship to the
# original plans. A child gets a copy of DNA. Inheritance means copy.
# Not in JS.  Some people say JS does not have inheritance but
# prtotypal inheritance.  This is misleading, according to Kyle. 

# In JS, we have an object arbitrarily called Foo.prototype. When we
# create an a1 object, notice that the arrow is going in opposite
# direction. It is not a copy but a behaviour link, or delegation link.
# The two mechanisms are intrinsically opposite. One is a copy-down the chain,
# the other is a delegation-up the chain. 
# For 20 years trying to make delegation mechanism work like classical 
# class inheritance.  
# Kyle prefers the term 'Behavior Delegation'
# It is more appropiate to say that JS has 'behaviour delegation' rather
# than prototypal inheritance, and that is a pattern we can adopt in
# our code. 
# When we call a1.speak(), it is not because a1 has got a copy of speak,
# but that a1 was able to delegate up the prototypal chain to an object
# that had a speak method on it.  

# OLOO
# Now Kyle is going to performa  magic trick... 
# Kyle is going to take code, epitomising the way
# people have bee doing it for twenty years, and he is going to
# simplify it so that we get the EXACT SAME functionality. 
# OLOO:  Objects linked to other objects. Kyle needed to have
# something to contrast with OO.  So... OLOO, as objects
# are all we care about in JS. Constructors, .prototype and 'new'
# keyword are all just distractions to get at linked objects. 
# Couldn't we just create the objects without the distraction and get
# the same benefits.  Will derive how we get to OLOO-style code
# over a couple of slides. The interim steps may look 'weird'. Keep
# an eye on the objects.

function Foo(who) {
this.me = who;
}
Foo.prototype.identify  = function () {
return "I am " + this.me
};

function Bar(who) {
Foo.call(this, who);
}

Bar.prototype = Object.create(Foo.prototype);
Bar.prototype.speak = function () {
console.log("Hello" + this.identify() + ".");
};
var b1 = new Bar("b1"); # // Line 17
b1.speak();
#// I am b1 

# The first thing that must be done to simplify the above code is
# to get rid of any rererence to a constructor, such as 'new Bar'
# OLOO Magic One

# Going to change line 17 to not deal with the new constructor
# Line 17 has now become two lines, temporarily worse. 
# Use Object.create to make a new object (b1) linked to the bar.prototype
# object. Now have to termporarily have to call that Bar function
# with b1 as my context. At least 'new' keyword has been
# gotten rid of.  No longer class instantiation. 

#We still have a b1 linked to a Bar.prototype linked to a 
#Foo.prototype. The below code does exactly the same thing
#as the previous code. 

function Foo(who) {
	this.me = who;
}

Foo.prototype.identify  = function () {
	return "I am " + this.me
};

function Bar(who) {
	Foo.call(this, who);
}

Bar.prototype = Object.create(Foo.prototype);
Bar.prototype.speak = function () {
	console.log("Hello" + this.identify() + ".");
};
var b1 = Object.create(Bar.prototype);
Bar.call(b1,"b1");
b1.speak();

# The next step it to get rid of all refs to .prototype. 
# OLOO Magic Two.

function Foo(who) {
	this.me = who;
}

Foo.prototype.identify  = function () {
	return "I am " + this.me;
};

var Bar = Object.create(Foo.prototype);
Bar.init = function (who) {
	Foo.call(this, who);
}

Bar.speak = function () {
	console.log("Hello" + this.identify() + ".");
};

var b1 = Object.create(Bar);
b1.init("b1");
b1.speak();

# Used Bar with capital 'B' just for consistency sake.  
# Not a constructor anymore. It is just an object, and we
# are putting properties directly on objects.  Look how much
# simpler. Link b1 directly to Bar. Use Object.create
# to do linkages. Object.create is the hero of the party. 

# Still b1 linked to Bar linked to Foo.prototype.
# Final step of the magic trick ..
# OLOO Magic Three. 

var Foo = {
	init: function (who) {
		this.me = who;
	},
	identify: function () {
		return "I am " + this.me;
	}
};

var Bar = Object.create(Foo);

Bar.speak = function () {
	console.log("Hello" + this.identify() + ".");
};

var b1 = Object.create(Bar);
b1.init("b1");
b1.speak();

# Now Foo itelf is just an object that has methods directly on it
# Bar is just an object that has methods directly on it.
# b1 is just an object that is linked to bar
# So still have in final tally an object linked to another
# object linked to another object. 
# All the same capability as three slides ago. But now have a
# syntax that removes all relationship to class-oriented thinking. 
# These are just peer objects that delegate to each other. 
# See in his this-and-objects prototype book. 
# Login authentication system is peer-object for example. One needs
# to delegate to the other so that the entire task of logging in
# gets done. So the login controller delegates to the authentication
# controller. So no parent/children and polymorphism.  A different
# way of thinking. Think in terms of objects delegating to other objects. 
# OLOO Questions (Audience)
# There is only one  prototype chain.
# No more constructors. But can still call init function. In this new
# syntax, have the capability to create all objects together in a  'pool'
# and wait until later to initialize. This capability not availbale
# with constructor-based coding.
# The above code will have the exacty same performance characteristics
# as previous.  Just simpler to get there. 
# OLOO is something he has invented recently.  Trying to evangalize
# the concept ...
# Delegation 'goes with the flow' of how javascript actually works. 
#
# Puts up diagram of new mental model. 
# This is extremely important. Note that 'me' method is on b1 (this.me ...)

# Argues that delegation is more natural. 
# Object.create ... 
# This is the polyfill for object.create.

if (!object.create) {
	object.create = function(o) {
		function f() {}
		f.prototype = o;
		return new f();
	};
}

#In effect we used a nice, clean utility to take all the 'crap' out of the code.

# https://gist.github.com/getify/5572383
# https://gist.github.com/getify/5226305

																		 # Quiz
#1 How is Javascript's [[Prototype]] chain not like traditional/classical
#inheritance?

# It does not copy, it links.  The 'arrows' go in opposite directions 

#2 What does "behaviour delegation" mean and how does it describe object
# linking in JS? 
# Objects delegate up the chain. Anytime you call a method or property on 
# an object and it cannot handle that property or method it delegates up
# the prototypal chain to the next object up. 
#3 Why is 'behaviour delegation' as a design pattern a helpful thing?
# What are the tradeoffs?

# You don't have copies of the functions
# With delegation, we are embracing the concept that all objects
# continue to exist and they are dyamically changing and that the
# linkage is a dynamic linkage at runtime. 
# With classes, abn object is a snapshot copy. If I change the
# parent class, I am not affecting the child.  With JS we are
# embracing the concept that Foo may change at runtime and
# Bar automatically gets to delegate to a changed Foo. So 
# actually a more powerful mechanism.  Delegation is more
# powerful than class beause you can implement classes in 
# delegation, but you cannot implement delegation in classes. 
# And what are tradeoffs?
# Shadowing is awkward. But ES6 adds Class and super keywords
# Another big disadvantage of delegataion is that everything
# is public. You lose all the advantages of encapsulation. 
# Prototypes are nice because there is only one copy of a method. 
# Less memory usage. Many times in Class, only one instance is
# often created! Create a hierarchy and then instantiate one of
# them. So why not create a single module....

                                  # Exercise 4
                                  # Asynchronous Patterns
#1 Callbacks
#2 Generators and co-routines
#3 Promises

setTimeout(function () {  # // Line One
console.log("callback");
},1000);
#The above is asynchonous code. Set up timer for 1000ms, then do other work, then 
#Oh! It is 1000ms. Time to execute callback.
#Multitasking is just fast context switching. 
# Callbacks are a continuation. First part of program runs until line one. Second
# part runs in 1000ms. The problem with callbacks is that they work OK in one split,
# but really start to 'suck' when there is more than one split. In almost all
# real-world code there is more than one split. 
# Callback Hell..
#
setTimeout(function () {
    console.log("one");
    setTimeout(function () {
        console.log("two");
        setTimeout(function () {
            console.log("three");
        }, 1000);
    },1000);
}, 1000);

# Callback hell has nothing to do with indentation! 
# Above clearly a bunch of nested functions. 
# But thi code does the exact same thing. 

function one(cb) {
    console.log("one");
    setTimeout(cb, 1000);
}

function two(cb) {
    console.log("two");
    setTimeout(cb, 1000);
}

function three() {
    console.log("three");
}

one(function(){
    two(three);
});


# Above is 'continuation passing' style. 
# Above code every bit as susecptible to the problems
# of callback hell as first example. 
# Callback hell must be something deeper than indentation
# and nesting.
# So what are problems with callbacks?
#1 What if setTimout function given above was not a 
# utility built into language that we can trust.
# What if it were some third-party library?
# Callbacks are a continuation. We that the entire
# rest of our program and wrap it in a function and
# say 'I want for YOU to exectute the rest of my
# program at some later time'. 
# So what happens if calling third-party library?
# Have given away an amazing amount of trust.
# We have done what is called 
# Inversion Of Control
# We used to be in control of completing of our progrm.
# As soon as we take continuation of our program
# and wrap it in a function and hand that off to some 
# other utility, we have lost control of our program. 
# An implicity trust has been created. 
# I trust that you will call my callback
# not too late
# not too early
# not too few times
# not too many times
# .....

# Gigantic amount of trust.  Say the third-party API
# charges a credit card, and there is a bug so  that
# callback is called a 1000 times.  Oops ...
# Implict problem with callback is giving control to 
# someone else. 
# How do we solve the inversion of control problem in
# a different way than with callbacks?

# Solving Callbacks
#
# trysomething_one.js

function trySomething(ok, err) {
    setTimeout(function () {
        var num = Math.random();
        if (num > 0.5) ok(num);
        else err(num);
    }, 1000);
}
trySomething( 
        function(num) {
            console.log("Success: " + num);
        },
        function(num) {
            console.log("Sorry: " + num);
        });

# But this is even more implicit trust! 
# What happens if they call the failure first?
# Or if both functions called together.

# Soo 'node-style'  or (Kyle prefers) 'error-first style'
#
# trysomething_two.js

function trySomething(cb) {
    setTimeout(function () {
        var num = Math.random();
        if (num > 0.5) cb(null,num);
        else cb("Too low!");
    }, 1000);
}

trySomething( 
        function(err,num) {
            if (err) {
                console.log(err);
            }
            else {
                console.log("Number: " + num) 
    console.log("Sorry: " + num);
            }
        });

# Really have not done anything to solve the implicit trust problem.

#meaning_of_life.js
function getData(d, cb) {
    setTimeout(function () {
        cb(d);
    }, 1000);
}

getData(10,function (num1) {
var x = 1+ num1;
getData(30, function (num2) {
    var y = 1 + num2;
    getData(
        "Meaning of Life: " + (x + y),
        function(answer) {
            console.log(answer);
            //Meaning of life: 42
        });
    });
});

#//Meaning of Life: 42

#Obvious that if we did not trust getData function would have
#massive inversion-of-control issue.  

# Generators
# Remember, the solution we are driving towards is to attempt to
# express asynchronous looking code in a synchronous looking fashion. 
# Will introduce the concept of generators, coming as of ES6.
Generators(yield)
# Generators break an assumption about JS code that has been
# there since the beginning of time.  When we start executing a
# piece of code assume that all lines of that piece of code will
# be executed before any other line runs. This is called the 
# 'run to completion' invariant of JS.
# Assume code can never be interruped, or paused, and come back. 
# The above is true of all normal functions. Not true of generators.
# We now have a new type of function that can literally pause itself
# in the middle of the funtion and can be resumed later. 
# That is why called generators. 
# New syntax. function *
#
#--------aside-------
# MDN generator definition
# A generator is a special type of function that works as a factory
# for iterators. A function becomes a generator if it contains 
# one or more yield expressions and if it uses the function* syntax.
# -----------end aside -----------

#generator_one.js (does not run on node.js) 
function* gen() {
   console.log("Hello");
   yield null;
   console.log("World");

}

var it = gen();  #//Line 7
it.next();
it.next();

# On line 7 it look like I execute the function. 
# But with generators, what you get is an iterator. 
# When you call a generator function, it actually constructs
# an iterator for you.  
# On line 8, when I call it.next(), start up the generator will
# will pause at next yield statement. 
# It pauses right there is middle of the function and returns
# control back to the program. In a minute, or five years from now
# I can call it.next() again. The generator will resume and run
# right to the end or until it reaches the next yield statement. 
# A generator can pause itself, and an iterator can resume it. 
# A generator is a funtion that does not even have to ever complete!
#
# coroutines.js (does not run on node)

var run = coroutine(function () {
    var x = 1 + (yield null);
    var y = 1 + (yield null);
    yield (x + y);
});

run(); #//line 7
run(10);
console.log(
        "Meaning of life: " + run(30).value
        );
# 'yield' can be thought of as a two-way message passing mechanism
# We can pass messages into generator, and receive messages back from
# generator. 
# When start up code by run() on line 7
# Continues to first yield which returns a null value
# At some later time I can say run(10) and '10' is passed in
# as expression result of yield, so 10+1, keeps going until next yield
# so pauses. Returns null again. At some later time run(30) (sic) so
# now yield 42 out as yield value of function. Two-way message passing.
# Above is all synchronous. 
# Now for asynchronous

function getData(d) {
    setTimeout(function () {
            run(d);
            }, 1000);
}
var run = coroutine(function* () {
        var x = 1 + (yield getData(10));
        var y = 1 + (yield getDate(30));
        var answer = (yield getData(
                "Meaning of life: " + (x + y)
                ));
        console.log(answer);
        });

run();

# When var x = 1 .. is called, it yields out to a function that in
# not immediately going to run.  It waits 1000ms before it iterates.

#The above code LOOKS  very synchronous. 
# But underneath the covers, the code will start and stop
# asynchronously.  That is power of generators. 
# Generators are the new thing! But very new (and very powerful).
# Drastically different from promises and callbacks.
# The future is that promises and generators will work together.

# Promises.
# What are they?
# Two methaphors. Order a burger in Supermacs.  No food, so
# cashier hands you a receipt.  When order no is called out exchange
# receipt for order. 
# That, metaphorically, is what a promise is

# The other metaphor. What if we call a function but
# we are unsure when that function is going to finish but that
# we could subscribe to an event that lets us know when that 
# function finished. A completion event, or a continuation event.
# A promise allows us to subscribe to a continuation event 
#
var wait = jQuery.Deferrrd();
var p = wait.promise();

p.done(function(value) { #// line 4
console.log(value);
});

setTimeout(function () {  #// line 8
wait.resolve(Math.random());
},1000);

#jQuery implemented promises in non-standard way, but Kyle says OK
# Lines 4-6 and 8-10 will likely happen in different places in real code
# 4-6 we are listening for event. The 'done'event
# At some later time in code resolve that promise.  Exchange for  a
# big Mac. 

# Here is an example of how it might be used

function waitForN(n) {
    var d = $.Deferred();
    setTimeout(d.resolve, n);
    return d.promise();
}

waitForN(1000)
    .then(function() {
            console.log("Hello world");
            return waitForN(2000);
            })
.then(function() {
        console.log("finally!")
        });

# When we call '.then' we are listening for continuation event
# on the promise. Then we call waitForN again, which generates
# a whole new promise... Chains promises together. 
# Can look at the code synchronously, although the code is
# running asynchronously.

# Here is why its important.  Remember inversion of control? 
# We have re-inverted the control. We hand our code to a utility
# and that utility hands us a promise back, and we get to decide
# what happens next. We are now in control of entire completion
# of program.  That is why promises are such a powerful
# solution to callback hell. They un-invert inversion-of-control.

#Promises are built-in natively as of ES6
#we are going to get 'capital P' Promise 
#Already there is Chrome and Node.

# This code works!
# note have just installed 'bluebird' library (github)

var Promise = require("bluebird");

function getData(d) {
return new Promise(
        function(resolve, reject) {
        setTimeout(function() {
            resolve(d); 
        }, 1000)
        });
}
var x;

getData(10)
    .then(function(num1) {
        x = 1 + num1;
        return getData(30);
    })
.then(function(num2) {
    var y = 1 + num2;
    return getData("Meaning of life: " + (x + y));
})
.then(function(answer) {
    console.log(answer);
    // Meaning of Life; 42
});

# In native promises, second function passed in handles errors.

#asynquence
# A library that Kyle wrote. 
# Promises can become very tedious.
# A number of libraries out there to help...
# Kyles is asynquence. 
# sequence = augomatically chained promises. 

ASQ()
    .then(function (done) {
            setTimeout(done, 1000);
            })
.gate(
        function(done) {
        setTimeout(done, 1000);
        },
        function () {
        setTimeout(done, 1000);
        })
.then(function() {
        console.log("2 seonds passed:");
        });
#So what is a gate?
# A sequence is this then this then this then this ...
# A gate says two or more things are going to happen at the same
# time, and I don't care which returns first or last, I am going 
# to wait for both to be finished before I move on. 

                             # Quiz Async Patterns

#1 What is "callback hell"? Why do callbacks suffer from "inversion
# of control"?
# Handing of control over to a third party.
#2 How do you pause a generator?
# yield
#3 How do you resume?
# next
#4 What is a Promise? How does it solve the inversiono of control issues?
# A promise is a future value. A transaction in burger King.
# Instead of passing my continuation in, I receive a promise back. 
# It un-inverts inversion of control. 
# How can we combine generators and promises for flow control?
# Call a generator, have it yield out a promise, when the 
# promise finishes have it re-start the generator.  

                                  # Exercise 5
# Source code is not written for computers. It is written for developers.
# All a computer cares about is ones and zeros. An infinite number of 
# souurce codes can produce the same pattern of ones and zeros. 
#
# Kyle uses .map().reduce  

# There are no threads in javascript. JS is a single-threaded language. 
# There is shared memory.
# It is common to put each chained element on a new line (from jQuery world). 
# --The End --
